1.Linux基本原则
	1.有目的单一的小程序组成 组合小程序完成复杂任务
	2.一切皆文件
	3.尽量避免捕获用户接口
	4.配置文件保存为文本格式
2.CLI接口
	命令格式
		1.命令 选项   参数：命令的作用对象
		       选项修命令执行方式(短选项-， 长选项--)
3.su: switch user 切换用户   su [-l] 用户名
4.认证机制 Authentication 授权Authorization  审计Audition(日志)
5.ls：list 列出
	-h human 
	-l long 
	-a all  
	. 当前目录 
	..上级目录 
	-A:不显示以上两个 
	-d:显示目录自身属性
	-i:index node inode 索引节点号
	-r:降序 默认为升序
	-R:Recursive 递归显示 
6.pwd: Print Working Directory
7.文件类型
	-:普通文件
	d:目录文件
	b:块设备文件 block
	c:字符设备文件character
	l:符号链接文件 symbolic link file
	p:命令管道文件pipe
	s:套接字文件socket

 文件权限：rwx 读写执行
 文件硬链接的次数
 文件的属主owner
 文件的属组group
 文件的大小size，单位是字节
 时间戳timestamp
8. cd:change directory 
	cd ~username：只有管理员权限才能进用户的home directory
	cd -:在当前目录和前一次所在的目录之间来回切换
9.命令类型：
	内置命令shell内置 内部 内建
	外部命令：在文件系统的某一个与命令名称相应的可执行文件
	type: 显示指定属于哪种类型
	环境变量：命名的内存空间 PATH:使用:分隔的路径 从PATH的路径中查找
10.date:时间管理 
	Linux：rtc晶体震荡 硬件时钟(clock) 系统时钟CPU模拟rtc(date)
	window:ntp 网络时间协议
11.获得命令的使用帮助
	1>.内部命令 help command
	  外部命令 command --help
 	2>.man command 
	3>.info command 在线文档
12.whatis command 
13.cal calendar 日历  cal , cal 2016
14.文件系统 FHS:Filesystem Hierarchy Standard 
	1./boot:系统启动相关的文件 如内核，initrd, 以及grub(bootloader)
	2./dev :设备文件
		块设备：  随机访问，数据块 
		字符设备：线性访问，按字符为单位 
	3./etc: 配置文件
	4./home:用户的家目录 每一个用户的目录通常默认为/home/username
	5./root:管理员的家目录
	5./lib: 库文件
		静态库 .a 
		动态库 .so shared object 
		/lib/modules:内核文件
	7./media:挂载点目录 将设备关联到系统的目录树下的某一个目录上 通常是移动设备
	  /mnt  :额外的临时文件系统
	8./opt :Optioanal add-on Apps 给主机额外安装软件所存放的目录
	9./proc:伪文件系统，内核的映射文件 内核的统计数据
	10./sys:伪文件系统，跟硬件设备相关的属性映射文件 通常实现硬件的管理
	11./tmp：临时文件 /var/tmp
	12./var：变化的文件
	13./bin：可执行文件，用户命令
	   /sbin:管理命令
	14./usr:Unix Software Resource shareable static  read-only 全局共享的自读文件 数据属于可分享的与不可变动的
		/usr/bin /usr/sbin /usr/lib /usr/local/bin /usr/local/sbin /usr/local/lib
	15.命名规则：
		1.长度不能超过255个字符
		2.不能使用/当文件名
		3.严格区分大小写
15.mkdir 创建目录 
	mkdir -pv ./test/hello/{x,y} 花括号的命令行展开
16.文件创建和删除
	touch
		-a ：访问时间
		-m ：修改时间
		-c ：改变时间
		-t ：修改时间戳 
	stat :查看文件属性
17.复制
	cp
	    -r:递归复制
	    -i:交互式的
	    -f:强制的 force
	    -p: --preserve=mode,ownership,timestamps
	    -d:复制所保持的链接文件
	    -a:打包归档 保持原有的所有属性 常用于备份
	
	install 
	    -d:创建目录
	    文件 目录 install 不能是复制目录到目录，只能是文件到目录
Gentoo:自己编译安装
LFS: Linux from Scratch 从0开始构建Linux
18. 查看文本
	cat tac: concatenate 对于多个文件连接并显示，对于单个文件是显示
		cat从头到尾显示 tac从尾到头显示  一下倾倒到屏幕
		-n:显示行号
		-E:显示行结束符 对于Linux文本文件的行结束符为$ 而window行结束符为$+\n
	分页查看
	more:支持向后翻页
	less: more is less q键退出
	head: 查看文件的前n行 -n 默认为10
	tail : 查看文件的后n行 -n 默认为10
	tail -f : --follow 查看文件尾部，不退出 等待显示后续追加至此文件的新内容
19.文本处理
	cut,join,sed,awk,grep
	cut -d : 以:分割 delimiter分割符 -f1 字段
		-d:指定字段分割符 默认为空格
		-f:指定要显示的字段 -f 1,3(1-3)
20.文本排序
	只影响显示的内容，对原文件没有影响
	sort: sort lines of text files 默认按字符ASCII升序排序
		-n:按数值排序 numeric-sort
		-r:reverse reverse the result of comparisons4
		-t:以字段分割符	
		-k:以哪个字段为关键字进行排序 常与-t连用
		-u:unique 相同的行只显示一次  uniq命令只认为相邻的并且重复的行认为是相同的行去掉重复行
		-f:--ignore-case 忽略字符大小写			
	uniq : report or omit repeated lines
		-c:count  显示文件中行重复的次数
		-d:duplicate 只显示重复的行
21.文本统计 wc word count 
	    行 单词 总字节
		-l:只显示行数
		-w:只显示单词数
		-c:只显示字节数
		-m:只显示字符数
		-L:最长的一行包含了多少个字符
22.字处理命令 tr -translate or delete characters 转换或删除字符
		tr [OPTION]... SET1 [SET2]
			tr ab AB < /etc/passwd  : 输入重定向
			tr -d:--delete 删除出现在字符集里的所有字符
23.bash
	pstree
	bash：再打开一个shell
	bash的特性
		1.命令历史 命令补全 命令别名
				history:查看命令历史 环境变量 HISTSIZE, echo $HISTSIZE :显示保存history size的大小
					-c:清空命令历史
					-d:offset delete the history entry at offset OFFSET指定第多少个命令 history -d 500 删除第500个命令
					-w:write保存命令历史保存至历史文件中
					-r:read the history file and append the contents
				命令历史使用技巧
					!n ：执行命令历史第n行的命令 ！323
					!-n:执行命令历史中倒数第n行命令 ！-4 倒数第4行
					!! :执行上一条命令
					! string:执行命令历史中最近一个以指定字符串string开头的命令
					!$:应用前一个命令的最后一个参数
					Esc . :同上
					Alt+.
					Tab :命令补全 路径补全
				命令别名
					alias cmdalias=command[选项] 在shell中定义的别名仅当在当前shell生命周期中有效，别名的有效范围仅为当前shell进程
					unalias + 别名 :撤销别名 
					\别名：当别名和原始的命令同名 并且是原始命令的扩展 使用\别名就是使用原始的命令
				命令替换 $(command)：把命令的执行结果替换成命令所在位置 或者使用 `command` 波浪线下的符号
					echo 'The current directory is $(pwd).'  echo "Dir is `pwd`." :使用双引号 反引号
					touch ./file-$(date +%F-%H-%M-%S).txt
				bash支持的引号：
						``:命令替换 将一个命令的输出作为另外一个命令的参数
						"":弱引用,可以实现变量替换 变量名到变量值的替换
						'':强引用，不完成变量替换
					
					

					  
		2.管道，重定向
		3.命令别名
		4.命令行编辑 
			光标跳转：ctrl+a 行首 
				  ctrl+e 行尾
				  ctrl+u 删除光标至命令行首的内容
				  ctrl+k 删除光标至命令行尾的内容
				  ctrl+d 删除光标所在的命令
				  ctrl+l 清屏

		5.命令行展开 
		6.文件名通配
		7.支持使用变量
		8.支持编程
24.文件名通配 globbing pathnames  #man 7 glob :查看文件名通配
	*  :匹配任意长度的任意字符
	?  :匹配任意一个字符
	[] :匹配指定范围内的任意单个字符
		[abc],[a-z],[A-Z],[0-9]，[0-9a-zA-Z]
		[:space:]:表示所有的空白字符的集合
		[:punct:]:表示所有的标点符号的集合
		[:lower:]:表示所有的小写字母的集合
		[:upper:]:表示所有的大写字母的集合
		[:alpha:]:表示所有的字母的集合
		[:digit:]:表示数字的集合 ls [[:digit:]]* :显示所有以数字开头的文件
		[:alnum:]:表示数字和大小写字母的集合

	[^]:匹配指定范围之外的任意单个字符 即不以指定的开头
	[^[:alpha:]]:非字母
	[[:alpha:]]*[[:space:]]*[[:alpha:]] a b
	[[:alpha:]]*[^[:alpha:]]:以字母开头以非字母结尾的
25.用户，组，权限
	安全上下文 secure context
	权限 r w x
	文件：
		r:可读，可以使用类似cat等命令查看文件内容
		w:可写，可以编辑或删除此文件
		x:可执行，executable,可以在命令提示符下当做命令提交给内核运行
	目录：
		r:可以对此目录执行ls以列出内部所有文件
		w:可以在此目录创建文件
		x:可以使用cd切换进此目录，也可以使用ls -l查看内部文件的详细信息，目录一般都有x权限
	rwx:
		0 000 ---：无权限
		1 001 --x: 执行
		2 010 -w-: 写
		3 011 -wx: 写和执行
		4 100 r--: 读
		5 101 r-x: 读和执行
		6 110 rw-: 读和写
		7 111 rwx: 读写执行
		
		755：rwxr-xr-x
	用户：UID, /etc/passwd 影子口令(密码)：/etc/shadow
	  组：GID, /etc/group  影子口令(密码): /etc/gshadow
	用户类别：
		管理员：UID 0
		普通用户: UID 1-65535
			系统用户:1-499
			一般用户:500-60000
	用户组类别：
		1.管理员组：
		  普通组
			系统组
			一般组
		2.私有组：创建用户时，如果没有为其指定所属的组，系统会自动为其创建一个与用户名同名的组
		  基本组：用户的默认组
		  附加组，额外组：默认组以外的组
	用户管理
		useradd userdel usermod passwd chsh chfn finger id chage 
		useradd -u UID 
			-g GID 基本组
			-G GID,... 附加组  useradd -G mygroup user3
			-c "注释信息" 
			-r 添加一个系统用户
			-d /path/to/directory 指定家目录  useradd -c "Tony Blare" -d /home/blare user4
			-M 没有家目录
			-s 指定用户默认的执行shell路径 useradd -s /sbin/nologin user5     切换 su user5
		userdel 
			-r 同时删除用户的家目录 默认不会删除家目录
		usermod 
			同useradd用法类似
			-L 锁定账号
			-U 解锁账号
		chsh  更改shell设置
		chfn  修改注释信息
	密码管理
	passwd [username]
		--stdin 标准输入读取密码 Linux哲学尽量不与用户交互 用管道的方式传递给passwd命令 echo '密码' | passwd --stdin user3
		-l 锁定账号
		-u 解锁账号
		-n 密码最短使用时间
		-x 密码最长使用时间
		-w 警告时间
		-i 非活动时间
		-d 删除账号密码 用户没有密码是不能登录的，Linux是禁止空密码登录
	pwck verify intgrity of password files 检查密码的完整性

		
		
		

			
		
	组管理
		groupadd groupdel groupmod gpasswd
		
		groupadd 
			-g GID
			-r 添加为系统组
		groupmod 
			-g GID
			-n 修改组名
		groupdel 删除组名
		
		gpasswd 给组加密码
		
		newgrp 登录到其他组
	
	
	
	chage     改变用户密码的过期时间
		-d 最近一次的修改时间
	    -E 过期时间
		-I 非活动时间
		-m 最短使用期限
		-M 最长使用期限
		-W 警告时间
		




	练习 
		1.创建一个用户mandriva 其ID号为2002，基本组为distro组ID为3003，附加组为linux
			# groupadd -g 3003 distro
			# groupadd linux
			# useradd -u 2002 -g distro -G linux mandriva
		2.创建一个用户fedora，其全名为Fedro Community 默认shell为tcsh
			# useradd -c "Fedro Community" -s /bin/tchs fedro
		3.修改mandriva的ID号为4004，基本组为linux,附加组为distro和fedora
			# usermod -u 4004 -g linux -G distro,fedora mandriva
		4.给fedora加密码，并设置其密码最短使用期限为2天，最长为50天
			# passwd -n 2 -x 50 fedora
		5.将mandriva的默认shell改为/bin/bash
			# usermod -s /bin/bash mandriva 
		6.添加系统用户hbase 且不允许其登录系统
	·	 	# useradd -r -s /sbin/nologin hbase
		
		
		
			
			
	权限管理
		chmod chgrp chown umask

		三类用户
			u 属主
			g 属组
			o 其他用户
			a 所有用户
		chown 改变文件属主(只有管理员可以使用此命令)
			# chown userowner file,...
				-R 修改目录及其内部文件 
				--reference=/path/to/somefile file,...  把file,...设定成与somefile同样的属主同时也改了属组	
			
		chgrp 改变文件属组 也只有管理员才可以使用此命令
			# chgrp groupname file,...
				-R 递归修改
		同时修改用户名和属组名
		chown username:groupname file,... 同时修改 chown :groupname file,...就只改组名
		chown username.groupname file,... 同上
		
		chmod 修改文件权限 
			1.可以修改三类用户的权限
				chmod 775 file/dir,... 注意位数不够时是从前面补0，例 chmod 75 file  就是075权限
					-R 递归修改文件下的所有文件
					--reference=/path/to/somefile file,... 
			2.也可以修改某类用户或某些用户权限 chmod user=mode file,...
				 chmod u=rwx /tmp/abc
				 chmod u=rwx,g=rw /tmp/abc 当不一样的时候用逗号隔开
				 chmod ug=rw /tmp/abc
				 chmod g=rx,o= /tmp/abc    省略既是对应位上没有权限
				 
			3.修改某类的用户某位或某些位权限
				 chmod user+/-mode file,...
				 chmod u-wx /tmp/abc
				 chmod u+x,g-x /tmp/abc
				 chmod a+x /tmp/abc  注a可以省略 chmod +x /tmp/abc
				 
		练习
			1.新建一个没有家目录的用户openstack
				# useradd -M openstack
			2.复制/etc/skel为/home/openstack
				# cp -r /etc/skel /home/openstack
			3.改变/home/openstack及其内部文件的属主属组均为openstack
				# chown -R openstack:openstack /home/openstack
			4./home/openstack及其内部文件，属组和属主和其他用户没有任何访问权限
 				# chmod -R go= /home/openstack
		验证操作成功 su -openstack
 		 
		手动添加用户hive 基本组为hive(5000),附加组为mygroup

		nano /etc/group   最后一行添加 hive:x:5000 在mygroup所在行添加hive
		nano /etc/passwd  最后一行添加hive:x:5000:5000:Hive:/home/hive:/bin/bash
		nano /etc/shadow  最后一行添加hive:!:16840:0:99999:7:::
		cp -r /etc/skel/ /home/hive
		chown -R hive:hive /home/hive
		chmod -R go= /home/hive
		openssl passwd 可以把密码生成秘钥 
			-1 :生成带加了8位杂质的秘钥 
		openssl passwd -1 -salt '12345678' ：生成秘钥$1$12345678$0ME5N6oDyoEAwUp7b5UDM/把它粘贴到/etc/shadow hive把!号替换 
		
		管理员的默认创建文件权限是644	文件夹是755
		普通管理员创建文件权限是664	文件夹是775
		
		umask: 遮罩码 root的遮罩码是0022 普通用户的遮罩码是0002  
		设定umask码 umask 022 修改之后只会在当前有效 退出后失效 在.bashrc中加上一行umask 022即可
		创建文件的权限是666-umask码 注意文件默认没有执行权限，如果算的结果中有执行权限时会自动加1  umask 023 试试 666-023=643 但是实际上是644
		创建目录的权限是777-umask码
		
		站在用户登录的角度来说，Shell的类型：
			1.登录式shell
				正常通常某终端登录
				su - username
				su -l username
			2.非登录的shell
				su username
				图形终端下打开命令窗口
				自动执行的shell脚本
		bash的配置文件
			全局配置 /etc/profile, /etc/profile.d/*.sh,以及/etc/bashrc
			个人配置 ~/.bash_profile, ~/.bashrc

		profile类的文件：设定环境变量  运行命令或脚本
		bashrc类的文件：设定本地变量 定义命令别名

		登录式shell如何读取配置文件？
			首先读取/etc/profile-->/etc/profile.d/*.sh -->~/.bash_profile -->~/.bashrc --> /etc/bashrc
		非登录式shell如何读取配置文件？
			首先读取~/.bashrc --> /etc/bashrc --> /etc/profile.d/*.sh

26./etc/passwd
	account:登录名
	password:密码
	UID
	GID
	comment:用户的额外信息
	Home Dir: 家目录
	Shell: 用户的默认shell
  /etc/shadow
	account：登录名
	encrypted passwrod:加密的密码
 /etc/shells : 指定了当前系统可用的安全shell
 /etc/login.defs
	


加密方法：
	对称加密：加密和解密使用同一个密码
	非对称加密，公钥加密：每个密码都成对加密，一个为公钥public key 一个为私钥secret key
	单向加密，散列加密：能加密不能解密  用于数据完整性校验  常用的有 MD5 Message Digest   SHA1:secure hash algorithm 
		 		1.不可逆
				2.雪崩效应 初始数据的微小改变将会引起结果的巨大变化 反逆破解
				3.定长输出
27.I/O重定向
	>:标准输出重定向 原有内容会被覆盖掉 而>>输出重定向会保留原有内容，追加输出
		     为了防止数据被覆盖 bash中有一个set命令 help set 中 -C开关关闭overwritten,+C打开
		     set -C：禁止对已经存在文件使用覆盖重定向 强制覆盖输出 则使用>|
		     set +C：关闭上述功能
	2>:错误输出重定向  ls /varr > /home/var.txt 但没有文件夹varr 此时/home/var.txt里没有内容
		      使用 ls /varr 2> /home/var.txt  则把错误输出写到文件中
		2>>：是使用追加的方式写入到文件中
		 
		ls -l /var > /home/var.txt 2> /home/err.out 正确则重定向到var.txt，错误则重定向到err.out 
	也可以  ls -l /var > /home/var.txt 2> /home/var.txt 一个文件不可能既是正确又是错误的,所以可以重定向到同一个文件里
		 
	&> :重定向标准输出或错误输出至同一个文件中
		以上命令就可以这样写
		ls /var &> /home/var.out  不管是标准输出还是错误输出都写到var.out下
	&>> :追加的方式


	<:标准输入重定向	
		而没有<<用法 <<：表示此处生成文档here document
	cat >> /home/sunyinhui/myfile.txt <<EOF	  把输入写入到文件中
28.管道:前一个命令的输出，作为另一个命令的输入  用于组合小命令完成复杂任务
	命令1 | 命令2 | 命令3 ...：把命令1的输出传递到命令2当做命令2的输入 甚至再传递到命令3
	echo 'hello world' | tr 'a-z' 'A-Z'
	cut -d: -f1 /etc/passwd | sort | tr 'a-z' 'A-Z' 
	
	命令tee :read from standard input and write to standard output and files 
		实现在终端输出也写入到文件
	echo 'hello world' | tee /home/sunyinhui/hello.out
	wc -l /etc/passwd | cut -d' ' -f1 ;  ' '表示空白字符
	
	练习：
		1.统计/usr/bin/目录下的文件个数
			# ls /usr/bin | wc -l : 注意ls不加-l参数 -l显示的第一行是total 45004 
		2.取出当前系统上所有用户的shell 要求 每种shell只显示一次 并且按顺序进行显示
			# cut -d: -f7 /etc/passwd | sort -u | wc -n
		3.显示/var/log/下所有文件的类型
			# file /var/log*
		4.取出/etc/inittab文件的第6行:先取前6行，再取最后一行
			# head -6 /etc/inittab | tail -1 
		5.取出/etc/passwd文件中的倒数第9个用户的用户名和shell,显示到屏幕上并将其保存到/tmp/users文件中
			# tail -9 /etc/passwd |head -1 |  cut -d: -f1,7 | tee /tmp/users
		6.显示/etc/下以pa开头的文件，并统计其个数
			# ls -d /etc/pa* | wc -l
		7.不使用文本编辑器，将alias cls=clear 一行内容添加至当前用户的.bashrc文件中
			# echo 'alias cls=clear' >> ~/.bashrc
29.grep：global  research expression 正则表达式  根据模式去搜索文本，并将符合模式的文本显示出来
 	 egrep,
	 fgrep fast grep :不支持正则表达式 
	
	Pattern:文本字符和正则表达式的元字符所组合起来过滤文本的匹配条件
	grep [options] pattern [file,...]
	grep [options] [-e pattern | -f file] [file,...]
	grep -i :忽略大小写
	     --color：加上颜色 加别名 alias grep='grep --color'
	     -v 显示没有匹配到的文本  --invert-match
         -o 只显示被匹配到的字符串
	     -E 扩展的正则表达式
	     -A n：After 连同显示匹配到所在行的下n行
	     -B n: Before                      上n行
	     -C n：Context                 上下各n行  context 上下文  
	通配符：
	* ：
	? :
	[]:
	[^]: 
	
	正则表达式 REGular EXPression REGEXP 
	   基本正则表达式 Basic expression
		元字符：
			.:任意单个字符
			[]:匹配指定范围内的单个字符
			[^]:匹配指定范围外的单个字符
			字符集合：[:digit:],[:lower:],[:upper:],[:punct:],[:space:],[:alpha:],[:alnum:]
				    grep '[[:digit:]]$' /etc/profile ：以数字结束的行
		字符个数：
			*：匹配其前面的字符任意次
			.*:任意长度的任意字符
			\?:匹配其前面的字符1次或0次   	
			\{m,n\}:匹配其前面的字符至少m次，至多n次
		位置锚定：
			^:锚定行首，此字符后面的任意字符必须出现在行首
			$:锚定行尾，此字符前面的任意字符必须出现在行尾
			^$:空白行
			\<或\b:锚定其后面的任意字符必须作为单词的首部出现
			\>或\b:锚定其前面的任意字符必须作为单词的尾部出现
			       \<root\> 就是在文本中查找root单词
		分组：
			\(\):
				ab*
				\(ab\)* :把ab当成一个整体
				 	He love his lover.
					She like her lover.
					He like his liker.
					She love her liker.
					
					
			向后引用
				\1:第一个左括号以及与之对应的右括号所包括的所有内容
				\2:第二个
				grep '\(l..e\).*\1r' test.txt		
	扩展正则表达式
		*:匹配其前字符任意次
		?:匹配其前字符1次或0次
		+:匹配其前字符至少匹配1次 相当于 \{1,\}
		{m,n}:不用加\	
		():分组 不加\
		| :或者， or  例如 C|cat 表示 C或者cat  | 整个左边或整个右边 
						   (C|c)at 表示要匹配Cat或者cat
		
	egrep '([1-9])'
	
	查找0-255
	egrep --color '(\<([0-9]|[1-9]|[0-9]|1[0-9][0-9]|2[0-9][0-9]|25[0-5])\>\.){3}\<([0-9]|[1-9]|[0-9]|1[0-9][0-9]|2[0-9][0-9]|25[0-5])\>'
	eg: ifconfig | egerp --color '(\<([0-9]|[1-9]|[0-9]|1[0-9][0-9]|2[0-9][0-9]|25[0-5])\>\.){3}\<([0-9]|[1-9]|[0-9]|1[0-9][0-9]|2[0-9][0-9]|25[0-5])\>'
	
	IPV4： A B C D E 
	A: 1-127
	B:128-191
	C:192-223
	
	IP地址匹配 
	
	

30.Shell编程

	脚本编程

	静态语言：编译型语言
		强类型 变量 变量在使用前，必须事先声明，甚至还需要初始化。
		事先转换成可执行格式
		C C++ JAVA 
	动态语言：解释型语言 on the fly
		弱类型 变量用时声明，甚至不区分类型
		边解释边执行
		PHP, shell, python, perl
	面向过程：
	面向对象：
	变量类型：事先确定数据的存储格式和长度
	变量: 内存空间，命名
	内存：编址的存储单元
31. Bash变量类型
	环境变量
	本地变量 局部变量
	位置变量
	特殊变量
	
	本地变量 VarName=Value  即可，在整个bash脚本中都可以使用。 set VarName=Value  set 可以省略 
	引用变量 $(VarName) :括号可以省略 ，在不至于变量名称混淆时可以省略。
			eg: #ANIMAL=pig
				#echo "There are some $ANIMALs."   最后输出There are some .
				#echo "There are some ${ANIMAL}s." 最后输出There are some pigs.
				#echo 'There are some ${ANIMAL}s.' 最后输出There are some $(ANIMAL)s.
	
		bash支持的引号：
		``:命令替换
		"":弱引用,可以实现变量替换 变量名到变量值的替换
		'':强引用，不完成变量替换
	
	局部变量 作用域只对当段代码有效
			加上local即可
			local VarName=Jerry 
		
	环境变量：作用域为当前shell进程及其当前子进程
			export VarName=Value
			或者
			VarName=Value
			export VarName
			
	
		脚本在执行时会启动一个子Shell进程
			命令行中启动的脚本会继承当前shell环境变量：
			如果是系统自动执行的脚本(非命令行启动)就需要自我定义需要各环境变量
	位置变量 
		$1,$2,... :位置变量是引用脚本的参数
		shift  如果参数太多，使用$1-$10,就太麻烦。shift就是当执行过第一个参数后，shift剔除第一个，然后第二个变成第一个参数，依次类推.
			   shift N 剔除N个 默认剔除1个
			#!/bin/bash
			echo $1
			shift
			echo $1
			shift
			echo $1
			
			bash shift.sh /rpp /rop /ddd
			就会输出 /rpp
					 /rop
					 /ddd
		help shift
			
				shift: shift [n]
				Shift positional parameters.
				
				Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is
				not given, it is assumed to be 1.
				
				Exit Status:
				Returns success unless N is negative or greater than $#.
		脚本，写一个脚本
			给脚本传递一个参数(整数)
			显示此两者之和，之积。测试给的参数够不够
				  1 #!/bin/bash
				  2 # 计算两个参数之和，之积，要测试参数个数
				  3 # 
				  4 if [ $# -lt 2 ]; then
				  5     echo "the arg must be two"
						echo "Usage: arg1, arg2"
				  6     exit
				  7 fi
				  8 
				  9 echo "The Sum is :$[$1 + $2]"
				  10 echo  "The prod is:$[$1*$2]"
		
		例如可以查看三个文件
			cat /etc/inittab /etc/fstab /etc/issue
			$1:对应的是/etc/inittab参数
			$2:对应的是/etc/fstab参数
			$3:对应的是/etc/issue参数
		练习 写一个脚本 filetest.sh
			能接受一个参数(文件路径)
				判断：此参数如果是一个存在的文件，就显示"OK"，否则就显示"No Such File"		
				  1 #!/bin/bash
				  2 #
				  3 if [ -e $1 ]; then
				  4     echo "OK"
				  5 else
				  6     echo "No such file"
				  7 fi 
		bash filetest.sh /etc/inittab  :No such file
		bash filetest.sh /etc/profile : Ok
		注意 当不给参数时，会输出Ok，所以要考虑这种没有给参数的情况
				  1 #!/bin/bash
				  2 #
				  3 echo $#  #显示参数的个数
				  4 echo $*  #显示参数列表
				  5 echo $@  #显示参数列表
				  6 
				  7 if [  $# -lt 1 ]; then
				  8     echo "Usage: bash filetest.sh arg1 [arg2...] "
				  9     exit 1
				 10 fi  
				 11 
				 12 if [ ! -e $1 ]; then
				 13     echo "No such file"
				 14     exit 1
				 15 else
				 16     echo "Ok"
				 17 fi
		

	
	特殊变量
		$?：保存上一个命令的执行状态返回值，有时只关心程序的状态结果
		程序执行完之后，可能有两个返回值
				1. 程序执行结果
				2. 程序状态返回代码(0-255)
					0:正确执行
					1-255:错误执行。系统预留了1,2,127 有特殊意义 
		$#: 参数的个数 
		$*：参数列表
		$@：参数列表
		
		输出重定向
		>
		>>
		2>
		2>>
		&>
		&>>
		/dev/null:设备，软件设备， bit bucket 位桶，能把所有的吞下去，吃人不吐骨头， 数据黑洞 
		所以把结果重定向到/dev/null上 ，结果就不会显示出来
		eg: ls /var &> /dev/null  
			有时不关心输出结果，只关心状态结果
			echo $?  查看是否成功 
			#sunyinhui@slave1:/root$ echo $?
			#0
			#sunyinhui@slave1:/root$ ls /varr
			#ls: cannot access /varr: No such file or directory
			#sunyinhui@slave1:/root$ echo $?
			#2
			
	撤销变量
		unset VarName 
	
	查看当前shell中变量
		set 
	查看当前shell环境变量 
		printenv
		env
		export
		
	shell中变量的值默认是字符串类型，不能做算术运算的
		A=2
		B=3
		C=$A+$B
		echo $C
	
	脚本是命令的堆砌，按照实际需要进行堆砌，结合命令流程控制机制实现的源程序
	
32. 条件测试类型：
			整数测试
			字符测试
			文件测试
			
	条件测试的表达式：
			[ expression ] :注意 中括号两边要有空格，否则是语法错误
		或
			[[expression]]
		或   test命令 test expression
	
	整数比较：
		-eq：等值比较：	 equal测试两个整数是否相等； 比如 $A -eq $B  
		-ne: 不等值比较：not equal测试两个整数不等的， 不等为真，等则为假
		-gt: 大于比较：  greater than测试一个数是否大于另一个数，大于为真，小于等于为假
		-lt:小于比较：	 lesser than 测试一个数是否小于另一个数，小于为真，否则为假
		-ge 大于或等于
		-le 小于或等于

	文件测试
		-e File ：表示文件是否存在
		-f File ：测试文件是否为普通文件
		-d File ：测试指定路径是否为目录的
		-r File ：测试当前用户对指定文件是否有可读权限
		-w
		-x
		
		[ -e /etc/passwd ]
		
	字符(串)测试
		== ：测试相等 一个或两个等于号  A=hello 
							   B=hi
							   [ $A = $B ] 或 [ '$A' == '$B' ] 或 [[ '$A' == '$B']]  注意空格
		!=  :测试不等
		>  : 测试大于
		<  ：测试小于
		-n string :测试指定字符串是否为空，空则真，不空为假
		-s string :测试指定字符串是否为不空，不空为真，空则为假
		
		
		
	命令间的逻辑关系：短路操作 ，当结果已经出现，以后的就不执行
		逻辑与：&&一假即假   id sunyinhui &> /dev/null  && echo "Hello！"
		逻辑或：||一真为真   id user || useradd user
	
	如果用户不存在就添加用户：! id user && useradd user 
	如果用户已经存在，就显示用户已存在，否则，就添加此用户
		id user && echo "user is exist" || useradd user 
	如果用户不存在，就添加，并且给密码为用户名，否则，显示其已经存在
		! id user &&　useadd user && echo "user" | passwd --stdin user || echo "user exists."
	
	如果/etc/profile 文件的行数大于30，就输出 "Large file" 
	[ `wc -l /etc/profile | cut -d' ' -f1` -gt 30  ] && echo "Large file"
	
		
	变量名称  
		1.字母、数字、下划线，不能以数字打头，
		2.不应跟系统中已有的环境变量重名
		3.要做到见名知意

	
	练习，写一个脚本，完成以下要求：
		1. 添加3个用户user1,user2,user3 但要先判断用户是否存在，不存在而后再添加；
		2. 添加完成后，显示一共添加了几个用户，当然，不能包括因为事先存在而没有添加的
		3. 最后显示当前系统上共有多少个用户
			
		  1 #!/bin/bash
		  2 
		  3 ! id user1 &> /dev/null && useradd user1 && echo "user1" | passwd --stdin user1 &> /dev/null || echo "user1 exists."
		  4 ! id user2 &> /dev/null && useradd user2 && echo "user2" | passwd --stdin user2 &> /dev/null || echo "user2 exists."
		  5 ! id user3 &> /dev/null && useradd user3 && echo "user3" | passwd --stdin user3 &> /dev/null || echo "user3 exists."
		  6 USER=`wc -l /etc/passwd | cut -d' ' -f1 `
		  7 
		  8 echo $USER users.
	练习 写一个脚本，完成以下要求：
		1.如果其UID为0，就显示此为管理员
		2.否则，就显示其为普通用户
		
		  1 #!/bin/bash
		  2 # UID为0，就显示为管理员，否则就显示为普通用户
		  3 #
		  4 
		  5 NAME=user1
		  6 USERID=`id  -u $NAME`
		  7 [ $USERID -eq 0 ] && echo "Admin" || echo "Common user."
	
	条件判断，控制结构：
			注意 当then与if在同一行 ; 不能省略。若then在下一行时，;可以省略。
		单分支的if语句
				if 判断条件; then   
					statement1
					statement2
					.....
				fi
		双分支的if语句：
				if 判断条件; then 
					statement1
					statement2
					....
				else
					statement3
					statement4
					....
				fi
		多分支的if语句
			if 判断条件1; then
				statement1
				...
			elif 判断条件2; then
				statement2
				...
			elif 判断条件3; then
				statement3
				...
			else 
				statement4
				...
			fi
			
	bash 有测试脚本有没有语法错误的功能
		bash -n 脚本名称
		bash -x 脚本 ：显示执行的语句
		
		
	
	练习 写一个脚本
		判断当前系统上是否有用户的默认shell为bash
		如果有，就显示有多少个这类用户，否则，就显示没有这类用户
		grep "\bbash$" /etc/passwd &> /dev/null  
		RETVAL=$? # 获得上一行执行状态结果。
		if [ $RETVAL -eq 0 ] ; then
			grep "\bbash$" /etc/passwd | wc -l
		echo 
			echo "No such user."
		fi
		
			1 #!/bin/bash
			2 # 
			3 grep "\bbash$" /etc/passwd &> /dev/null
			4 RETVAL=$?
			5 if [ $RETVAL -eq 0 ]; then
			6    users=` grep "\bbash$" /etc/passwd | wc -l`           # 命令的引用
			7    echo "Default shell is bash there  are $users users."
			8 else 
			9     echo "No such user."
			10 fi
				
		提示：
			`引用` 一个命令的执行结果，要使用命令引用，比如 users=`grep "\bbash$" /etc/passwd | wc -l`
			使用一个命令的执行状态结果，要直接执行此命令，一定不能引用，比如 if id user 一句中的id命令就一定不能加引号
			如果想把一个命令的执行结果赋给某变量，要使用命令引用，比如 userid=`id -u user`
			如果想要把一个命令的执行状态结果保留下来，并作为命令执行成功与否的判断标准，则需要先执行此命令，而后引用其状态结果，如
				id -u user
				RETVAL=$?
				此句，绝对不可写为 RETVAL=`id -u user`
				
	练习 写个一个脚本
		判断当前系统上是否有用户的默认shell为bash；
		如果有，就显示其中一个的用户名，否则，就显示没有这类用户
			  1 #!/bin/bash
			  2 # 
			  3 grep "\bbash$" /etc/passwd &> /dev/null
			  4 RETVAL=$?
			  5 if [ $RETVAL -eq 0 ]; then
			  6    AUSER=`grep "\bbash$" /etc/passwd | head -1 | cut -d: -f1`
			  7    echo  " $AUSER  is the such user."
			  8 else
			  9     echo "No such user."
			 10 fi
	
	练习 写一个脚本
		给定一个文件，比如/etc/inittab
		判断这个文件中是否有空白行
		如果有，就显示其空白行数，否则，显示没有空白行
			  1 #!/bin/bash
			  2 #判断是否存在空白行，若有，就显示行号，否则就显示没有空白行
			  3 # 
			  4 
			  5 grep "^$" /etc/profile &> /dev/null
			  6 space=$?
			  7 if [ $space -eq 0 ]; then
			  8     Num=`grep '^$' /etc/profile | wc -l `
			  9     echo "the space is local at $Num"
			 10 fi
        改进：若文件不存在，就没有必要继续执行 
			  1 #!/bin/bash
			  2 # 改进，若文件不存在，就没有必要继续执行
			  3 FILE=/etc/profile
			  4 if [ ! -e $FILE ]; then
			  5     echo "No Such the $FILE "
			  6     exit 1
			  7 fi
			  8 
			  9 if grep "^$" $FILE &> /dev/null;then
			 10     echo "Total blank lines: `grep "^$" $FILE | wc -l ` ."
			 11 else
			 12     echo "No blank lines."
			 13 fi

		
		
		
	练习 写一个脚本
		给定一个用户，判断其UID和GID是否一样
		如果一样，就显示此用户为“good guy”， 否则 就显示此用户为“bad guy”
			  1 #!/bin/bash
			  2 # 判断用户的UID和GID是否一致
			  3 User=sunyinhui
			  4 UserUID=`id -u $User`
			  5 UserGID=`id -g $User`
			  6 if  [ $UserUID -eq $UserGID ]; then
			  7     echo "good guy"
			  8 else
			  9     echo "bad guy"
			 10 fi
		进一步要求，不使用id命令获得其id号 查看 /etc/passwd
		
		
			
	练习 写一个脚本
		给定一个用户，获取其密码警告期限；
		而后判断 用户密码使用期限是否已经小于警告期限； 计算方法，最长使用期限减去已经使用的天数即为剩余使用期限。
		如果小于，则显示“Warning”;否则 就显示“OK”
			提示：算术运算的方法 $[$A-$B] 表示变量A的值减去变量B的值的结果。
			  1 #!/bin/bash
			  2 # 获得警告期限
			  3 # 
			  4 User=sunyinhui
			  5 W=`grep  "$User:" /etc/shadow |cut -d: -f6 `
			  6 S=`date +%s`
			  7 T=`expr $S/86400`
			  8 L=`grep "$User:" /etc/shadow |cut -d: -f5`
			  9 N=`grep "$User:" /etc/shadow |cut -d: -f3`
			 10 SY=$[$L-$[$T-$N]]
			 11 
			 12 if [ $SY -lt $W ]; then
			 13     echo "Warning"
			 14 else
			 15     echo "Ok"
			 16 fi  
			
			
			
			
			
	
	练习 写一个脚本
		判定命令历史中历史命令的总条目是否大于1000，如果大于，则显示“Some command will gone”，否则显示“OK”
		注意 history | wc -l : history 只保留1000命令，所以要在/root/.bash_history中查看。cat /root/.bash_history | wc -l
			  1 #!/bin/bash
			  2 # 判断history条目是否大于1000
			  3 
			  4 HISTORY=`cat /root/.bash_history | wc -l`  # history | tail -1 | cut -d' ' -f2 也可以取出行号
			  5 if [ $HISTORY -gt 1000 ]; then
			  6     echo "Some command will gone"
			  7 else
			  8     echo "OK"
			  9 fi
		
		

	在shell中进行加减乘除运算
		A=3
		B=6
		1.let命令  help let
				let expression   如 let C=$A+$B  echo $C
		2.$[expression]
			    D=$[$A+$B]  echo $D
		3 $((算术运算表达式))
				E=$(($A+$B))  echo $E
		4 expr 算术运算表达式 ；注意表达式中各操作符及运算符之间要有空格，而且要使用命令引用
			C=`expr $A + $B`
		
	 exit 退出脚本 
		exit n : 当n取非0的整数。
		如果脚本没有明确定义退出状态码，那么，最后执行的一条命令的退出码即为脚本的退出状态码
		
		
	练习 写一个脚本
		给定一个文件：
		如果是一个普通文件，就显示之
		如果是一个目录，亦显示之
		否则，此为无法识别的文件
		#!/bin/bash
		FILE=/etc/passwd
		if [ ! -e $FILE ];then
			echo "$FILE is not exist. "
			exit 1
		elif [ -d $FILE ]; then
			echo "$FILE is a directory"
		elif [ -f $FILE ];then
			echo "$FILE is a file."
		else 
			echo "can not recongrection the $FILE "
		fi
	bash变量的类型
		本地变量(局部变量)
		环境变量 
	
	
33. sed 流编辑器  awk 
	sed stream EDitor 纯ASCII文本的
		行编辑器 把一行读到内存中，在内存空间与给定的模式匹配，若匹配，也叫作sed的模式空间，在模式空间上进行操作。 而后将模式空间中的内容显示出来。
		默认情况下，不编辑原文件，仅对模式空间上的数据做处理
		
	sed [options]'AddressCommand' file,...  :Address 指定对那些行做出处理，Command命令做出操作。在Address 和 Command 之间不需要添加空白字符。
			options:
						-n :静默模式 即为 不显示模式空间上的内容
						-i :直接在原文件中修改 注意系统文件的修改  最好先做备份
						-e Script -e Script ...: 支持同时执行多个脚本。 脚本的含义就是'AddressCommand'
						-f File: 读取文件，执行文件中的命令
									sed -f /path/to/script file  注意可以把 -e后的S多个Script写在一个脚本中
						-r :表示使用扩展的正则表达式
						
		Address：
				1、StartLine,EndLine :起始行，结束行 比如 1,100   
				   $:最后一行
				   $-1:倒数第二行   
				2、/RegExg/ 正则表达式 例如 /^root/ 就是找文件中以root开头的行  
					注意 要用双斜线引起来
				3、/Pattern1/,/Pattern2/ 表示从第一次被模式1匹配的行开始，到第一次被模式2匹配的行结束
				4、LineNumber 精确到某行
				5、StartLine,+N ：从StartLine开始，向后的N行
		Command：单引号，双引号都可以
				d: delete 删除符合条件的行。 sed "3,$d" /etc/fstab    
											 sed "/root/d" /etc/fstab
											 sed "1,+2d" /etc/fstab
					删除以/开头的行 需要转义
											 sed "/^\//d" /etc/fstab  
				p: print 显示符合条件的行
											 sed "/^\/p/" /etc/fstab  显示以/开头的行  注意会显示两次
											 sed -n '/^\//p' /etc/fstab 静默模式显示匹配到的行
				a: add 在匹配到的行后面新增一行  \string 在指定的行后面追加新行，内容为string
											 sed '/^\//a \#hello world' /etc/fstab   在匹配的模式下添加一行
											 sed '/^\//a \#hello world\n# hello linux' /etc/fstab 在匹配的模式下添加两行
																	  \n ：实现换行
				i: insert 在指定的行前面添加新行  \string 内容是string
											sed "/^#/i \hello world" /etc/fstab
				r File :将指定的文件添加到匹配到的行后面 
											sed '1,2r /etc/issue' /etc/fstab  在第一行和第二行后面添加/etc/issue 文件中的内容
				w File ：将指定范围内的内容所在的行另存至指定的文件中。
											sed '/root/w /tmp/root.txt' /etc/fstab 
												将文件中/etc/fstab包含root的行写入到/tmp/root.txt文文件中
				s/pattern/string/ :查找并替换 将匹配到的模式pattern替换为指定的string	注意 有三个斜线 ，不仅限于斜线，还可以使用#和@
									默认只替换每行中第一次被匹配到的模式
										s/pattern/string/修饰符
										修饰符 g: 全局替换
											   i: 忽略字符大小写
											   
													   
									sed 's/root/ROOT/' /etc/fstab 
									sed 's/^\//#/' /etc/fstab
									sed 's/\//#/' /etc/fstab  没有全局替换
									sed 's/\//#/g' /etc/fstab
							
								s### 不需要转义 注意 pattern和string中不要出现#号 ,如遇#号使用@ sed  's@/@#@g' /etc/fstab
								s@@@ 不需要转义  同上 
					向后引用 
							test.txt  
									i  like her 
									she is my love
						    查找l..e 然后替换成l..er
									sed 's#\(l..e\)#\1r#g' test.txt
					&: 引用模式匹配整个串 
									sed 's#l..e#&r#g' test.txt

									root@slave1:~# grep '\(l..e\).*\1r' test.txt
									He love his lover
									root@slave1:~# sed  's#\(l..e\)#\1r#g' test.txt      
									He lover his loverr
									She liker her loverr

									root@slave1:~# sed 's#l..e#&r#g' test
									testif2.sh  testif.sh   test.txt    
									root@slave1:~# sed 's#l..e#&r#g' test.txt 
									He lover his loverr
									She liker her loverr
									
									
						把live->Live love->Love
									sed 's#l\(..e\)#L\1#g' test.txt
 									
							root@slave1:~# sed 's#l\(..e\)#L\1#g' test.txt
							He Love his Lover
							She Like her Lover
			
				把 命令history显示的行首空格去掉 
							history | sed 's#^[[:space:]]*##g' :可以删除行首的任意空白字符
							history | sed 's#^[[:space:]]*##g' | cut -d' ' -f1
	sed练习 
		1. 删除/etc/grub.conf 文件中行首的空白符
			sed -r 's@^[[[:space:]]+@@g' /etc/grub.conf
		2. 替换/etc/inittab文件中'id:3:initdefault:'一行中的数字为5
			sed 's@\(id:\)[0-9]\(:initdefault\)@\15\2@g' /etc/inittab
		3. 删除/etc/inittab文件中的空白行
			sed '/^$/d' /etc/inittab
		4. 删除/etc/inittab文件中开头的#号
			sed 's@^#@@g' /etc/inittab
		5. 删除某文件中开头的#号，及后面的空白字符，但要求#号后面必须有空白字符
			sed -r 's@^#[[:space:]]+@@g' /etc/inittab
		6. 删除某文件中以空白字符后面跟#号开头的行中，开头的空白字符及#
			sed  -r 's@^[[:space:]]+#@@g' /etc/inittab
		7. 取出一个文件路径的目录名称
			echo '/etc/rc.d' | sed -r 's@^(/.*/)[^/]+?@\1@g' 
			其中 rc.d叫作基名
			echo '/etc/rc.d' | sed -r 's@^/.*/([^/]+?)@\1@g' 
		
	练习 
	
		0 写一个脚本 
		  传递一个参数给脚本，如果参数为q Q quit Quit，就退出脚本，否则，就显示用户的参数
				  1 #!/bin/bash
				  2 if [ $1 == '[q Q quit Quit]' ]; then
				  3     exit
				  4 else
				  5     echo $1
				  6 fi
		  
		  
		  
	    1 传递一个用户名参数给脚本，判断此用户的用户名跟基本组的组名是否一致，并将结果显示出来
		字符串比较 
				  1 #!/bin/bash
				  2 # 测试用户
				  3 if ! id $1 &> /dev/null; then
				  4     echo "No Such user."
				  5     exit 10
				  6 fi  
				  7 
				  8 if [ `id -n -u $1` == `id -n -g $1` ]; then
				  9     echo 'conform'
				 10 else
				 11     echo 'not conform'
				 12 fi
						
						
		
		
		2 传递三个参数给脚本，第一个为整数，第二个为算术运算符，第三个为整数，将计算结果显示出来，要求保留两位整数，行如： ./calc.sh 5 / 2 
			提示：将参数传递给bc  scale=2 保留两个小数
		    	echo 'scale=2;111/22;' | bc
			或
				bc <<< "scale=2;111/22;"
			
		
		3 传递3个参数给脚本，参数为用户名，将这些用户的账号信息提取出来后放置于/tmp/testusers.txt文件中，并要求每一行行首有行号。
		
		
		4 写一个脚本 判断当前主机的cpu生产商，其信息在/proc/cpuinfo 文件中vendor id 一行中
	      如果其生产商为AuthenticAMD，就显示其为AMD公司
		  如果其生产商为AuthenticIntel，就显示其为Intel公司， 否则就显示为非主流公司
		
		5  写一个脚本，给脚本传递三个整数，判断其中的最大数和最小数，并显示出来
			
	循环 :进入循环、退出循环 
		1 for 
		2 while
		3 until
		
		for 变量 in 列表; do     或    for  变量 in 列表; 
			循环体                     do  
		done                                循环体
									   done 
		
		如何生成列表：
				{1..100}  两个点
				seq 起始数， 步进长度， 结束数
		
		声明一个变量 
			declare -i SUM=0
					-i integer 整数
					-x export 将变量声明为环境变量
		从1加到100：
				  1 #!/bin/bash
				  2 declare -i SUM=0
				  3 
				  4 for I in {1..100};do 
				  5     SUM=$[$SUM+$I]
				  6 done
				  7 
				  8 echo $SUM
				  
		向系统中的每个用户说Hello 
				  1 #!/bin/bash
				  2 # 向系统中的每个用户说hello
				  3 
				  4 declare -i LINES=`wc -l /etc/passwd |cut -d' ' -f1`
				  5 
				  6 for I in `seq 1 $LINES`;do
				  7   Str=` head -n $I /etc/passwd | tail -1 | cut -d: -f1`
				  8   echo "hello $Str"
				  9   done		
		
		
34 Vim
    Vi : Visual Interface 
	Vim : Visual Interface Improved  vi增强版
		全屏编辑器 模式编辑器，模式之间可以转换
	Vim模式 默认处于命令模式
		命令模式：
		输入模式：
		末行模式：
	模式转换：
		命令模式->输入模式
			输入模式
				i:当前光标所在字符前面，转换为输入模式
				a:当前光标所在字符后面，转换为输入模式
				o:当前光标行的下面，新建一行，并转换为输入模式
				I：在当前光标所在行的行首，转换为输入模式
				A: 在当前光标所在行的行尾，转换为输入模式
				O: 在当前行的上方，新建一行，并转换为输入模式
		输入模式->命令模式
				ESC 
		命令模式->末行模式  (只能从命令模式进入末行模式，不能从输入模式进入末行模式)
			末行模式
				：
				:nd 	删除第n行
				:n,md	删除n-m行
				:.,+nd 	删除当前行及其下n行
				:.,nd	删除当前行到第n行
				:! ls /etc
				
				其中：
					.：		表示当前行
					$：		最后一行
					$-n:	倒数第n行
					+n:		向下n行
					
				
				
				
		末行模式->命令模式
				ESC（当末行模式有参数时，需要两个ESC）
				
			
	
	一 打开文件	
			# vim /path/to/file 打开单个文件
			vim +n  /path/to/file    直接打开文件的第n行
			vim + /path/to/file      直接打开文件的尾部
			vim +/pattern file      打开文件，第一次定位到匹配到模式的行首
	
	二 关闭文件
			1. 在末行模式下关闭文件
				w :	保存，对于普通用户只有读权限是不起作用的。
				w!: 强行保存，只对管理员而言。
				q :	不保存，退出
				wq:	保存并退出
				x : 保存并退出
				q!: 强行退出
			2. 在命令模式下关闭文件
				ZZ：保存并退出
	
	三 移动光标 在命令模式下
			1. 逐字符移动光标：
				h:向左
				l:向右
				j:向上
				k:向下
					注意 nh:向左移动n个字符
						 nl:向右移动n个字符
						 nj
						 nk
			2. 逐单词移动
				w:移动至下一个单词词首
				e:移动至下一个单词词尾
				b:移动至上一个单词词首
					注意 nw ne nb
			3. 行内跳转
				0:数字0 跳至行首 绝对行首
				^:跳至行首 相对行首，第一个非空白字符
				$:行尾
			4. 句和段之间跳转
				():移动光标到下一个句子 )，移动光标到上一个句子(
				{}:移动到段首{，移动到段尾}
			5. 行间跳转
				nG :跳转至第n行
				G  ：最后一行
				在末行模式下，直接给出行号即可。跳到第n行
				
	四 翻屏操作
		ctrl + f : 向下翻屏
		ctrl + b : 向上翻屏
		ctrl + d ：向下翻半屏 down
		ctrl + u : 向上翻半屏 up 
	
	五  删除单个字符
		x: 删除光标所在的单个字符，支持nx操作，删除光标所在处，及其以后的n个字符
		
	六 删除命令  :d 跟跳转命令结合使用，还支持 ndw 
		dd：删除光标所在行， 
		ndd:从当前光标所在行在内的n行
		d$: 删除光标所在位置直至行尾
		d^: 删除光标所在位置直至行首
		d0: 同上
		dw：删除光标所在位置的下一个单词
		de: 
		db：
		
	七 复制命令 y  用法同d 
		yy 		复制一行
		3yy		复制3行
		
	八 粘贴命令 p/P
		小写p: 	如果删除或复制为整行内容，粘贴到光标所在行的下行
				如果删除或复制为非整行内容，粘贴至光标所在字符的后面
		大写P：	如果删除或复制为整行内容，粘贴到光标所在行的上行
				如果删除或复制为非整行内容，粘贴至光标所在行的前面
		
	九 撤销命令  u: undo 
		u 
		连续操作可以连续撤销
		或 
		nu : 直接撤销至上n次便捷操作
		
		撤销自己的撤销操作 Ctrl + r 
			当撤销到一定的位置，发现自己多撤销了，就使用ctrl + r 还原最后一次的撤销操作
	
	十 修改：先删除内容，在转换为输入模式 ：替换修改
		c: change  用法同d
	
	十一 替换 R和r
			r+替换字符：当在替换单个字符时用
			R+ 替换 ：进入替换模式，可以连续替换
	
	十二  重复前一次的操作
			. : 重复前一次的重复操作
			
	十三  可视化模式 V v  可以选中光标所滑过的所有字符
			v ： 按字符选取
			V :	 按矩形选取
	
	十四 查找  支持正则表达式
			/pattern  ：从文件首部向尾部查找
			?pattern  :
	
	十五 替换 s
		在末行模式下使用s命令，用法同sed 
		:s/if/IF/g
		
	
			
			
	
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
