1.Linux基本原则
	1.有目的单一的小程序组成 组合小程序完成复杂任务
	2.一切皆文件
	3.尽量避免捕获用户接口
	4.配置文件保存为文本格式
2.CLI接口
	命令格式
		1.命令 选项   参数：命令的作用对象
		       选项修命令执行方式(短选项-， 长选项--)
3.su: switch user 切换用户   su [-l] 用户名
4.认证机制 Authentication 授权Authorization  审计Audition(日志)
5.ls：list 列出
	-h human 
	-l long 
	-a all  
	. 当前目录 
	..上级目录 
	-A:不显示以上两个 
	-d:显示目录自身属性
	-i:index node inode 索引节点号
	-r:降序 默认为升序
	-R:Recursive 递归显示 
6.pwd: Print Working Directory
7.文件类型
	-:普通文件
	d:目录文件
	b:块设备文件 block
	c:字符设备文件character
	l:符号链接文件 symbolic link file
	p:命令管道文件pipe
	s:套接字文件socket

 文件权限：rwx 读写执行
 文件硬链接的次数
 文件的属主owner
 文件的属组group
 文件的大小size，单位是字节
 时间戳timestamp
8. cd:change directory 
	cd ~username：只有管理员权限才能进用户的home directory
	cd -:在当前目录和前一次所在的目录之间来回切换
9.命令类型：
	内置命令shell内置 内部 内建
	外部命令：在文件系统的某一个与命令名称相应的可执行文件
	type: 显示指定属于哪种类型
	环境变量：命名的内存空间 PATH:使用:分隔的路径 从PATH的路径中查找
10.date:时间管理 
	Linux：rtc晶体震荡 硬件时钟(clock) 系统时钟CPU模拟rtc(date)
	window:ntp 网络时间协议
11.获得命令的使用帮助
	1>.内部命令 help command
	  外部命令 command --help
 	2>.man command 
	3>.info command 在线文档
12.whatis command 
13.cal calendar 日历  cal , cal 2016
14.文件系统 FHS:Filesystem Hierarchy Standard 
	1./boot:系统启动相关的文件 如内核，initrd, 以及grub(bootloader)
	2./dev :设备文件
		块设备：  随机访问，数据块 
		字符设备：线性访问，按字符为单位 
	3./etc: 配置文件
	4./home:用户的家目录 每一个用户的目录通常默认为/home/username
	5./root:管理员的家目录
	5./lib: 库文件
		静态库 .a 
		动态库 .so shared object 
		/lib/modules:内核文件
	7./media:挂载点目录 将设备关联到系统的目录树下的某一个目录上 通常是移动设备
	  /mnt  :额外的临时文件系统
	8./opt :Optioanal add-on Apps 给主机额外安装软件所存放的目录
	9./proc:伪文件系统，内核的映射文件 内核的统计数据
	10./sys:伪文件系统，跟硬件设备相关的属性映射文件 通常实现硬件的管理
	11./tmp：临时文件 /var/tmp
	12./var：变化的文件
	13./bin：可执行文件，用户命令
	   /sbin:管理命令
	14./usr:Unix Software Resource shareable static  read-only 全局共享的自读文件 数据属于可分享的与不可变动的
		/usr/bin /usr/sbin /usr/lib /usr/local/bin /usr/local/sbin /usr/local/lib
	15.命名规则：
		1.长度不能超过255个字符
		2.不能使用/当文件名
		3.严格区分大小写
15.mkdir 创建目录 
	mkdir -pv ./test/hello/{x,y} 花括号的命令行展开
16.文件创建和删除
	touch
		-a ：访问时间
		-m ：修改时间
		-c ：改变时间
		-t ：修改时间戳 
	stat :查看文件属性  status ：状态
17.复制
	cp
	    -r:递归复制
	    -i:交互式的
	    -f:强制的 force
	    -p: --preserve=mode,ownership,timestamps
	    -d:复制所保持的链接文件
	    -a:打包归档 保持原有的所有属性 常用于备份
	
	install 
	    -d:创建目录
	    文件 目录 install 不能是复制目录到目录，只能是文件到目录
Gentoo:自己编译安装
LFS: Linux from Scratch 从0开始构建Linux
18. 查看文本
	cat tac: concatenate 对于多个文件连接并显示，对于单个文件是显示
		cat从头到尾显示 tac从尾到头显示  一下倾倒到屏幕
		-n:显示行号
		-E:显示行结束符 对于Linux文本文件的行结束符为$ 而window行结束符为$+\n
	分页查看
	more:支持向后翻页
	less: more is less q键退出
	head: 查看文件的前n行 -n 默认为10
	tail : 查看文件的后n行 -n 默认为10
	tail -f : --follow 查看文件尾部，不退出 等待显示后续追加至此文件的新内容
19.文本处理
	cut,join,sed,awk,grep
	cut -d : 以:分割 delimiter分割符 -f1 字段
		-d:指定字段分割符 默认为空格
		-f:指定要显示的字段 -f 1,3(1-3)
20.文本排序
	只影响显示的内容，对原文件没有影响
	sort: sort lines of text files 默认按字符ASCII升序排序
		-n:按数值排序 numeric-sort
		-r:reverse reverse the result of comparisons4
		-t:以字段分割符	
		-k:以哪个字段为关键字进行排序 常与-t连用
		-u:unique 相同的行只显示一次  uniq命令只认为相邻的并且重复的行认为是相同的行去掉重复行
		-f:--ignore-case 忽略字符大小写			
	uniq : report or omit repeated lines
		-c:count  显示文件中行重复的次数
		-d:duplicate 只显示重复的行
21.文本统计 wc word count 
	    行 单词 总字节
		-l:只显示行数
		-w:只显示单词数
		-c:只显示字节数
		-m:只显示字符数
		-L:最长的一行包含了多少个字符
22.字处理命令 tr -translate or delete characters 转换或删除字符
		tr [OPTION]... SET1 [SET2]
			tr ab AB < /etc/passwd  : 输入重定向
			tr -d:--delete 删除出现在字符集里的所有字符
23.bash
	pstree
	bash：再打开一个shell
	bash的特性
		1.命令历史 命令补全 命令别名
				history:查看命令历史 环境变量 HISTSIZE, echo $HISTSIZE :显示保存history size的大小
					-c:清空命令历史
					-d:offset delete the history entry at offset OFFSET指定第多少个命令 history -d 500 删除第500个命令
					-w:write保存命令历史保存至历史文件中
					-r:read the history file and append the contents
				命令历史使用技巧
					!n ：执行命令历史第n行的命令 ！323
					!-n:执行命令历史中倒数第n行命令 ！-4 倒数第4行
					!! :执行上一条命令
					! string:执行命令历史中最近一个以指定字符串string开头的命令
					!$:应用前一个命令的最后一个参数
					Esc . :同上
					Alt+.
					Tab :命令补全 路径补全
				命令别名
					alias cmdalias=command[选项] 在shell中定义的别名仅当在当前shell生命周期中有效，别名的有效范围仅为当前shell进程
					unalias + 别名 :撤销别名 
					\别名：当别名和原始的命令同名 并且是原始命令的扩展 使用\别名就是使用原始的命令
				命令替换 $(command)：把命令的执行结果替换成命令所在位置 或者使用 `command` 波浪线下的符号
					echo 'The current directory is $(pwd).'  echo "Dir is `pwd`." :使用双引号 反引号
					touch ./file-$(date +%F-%H-%M-%S).txt
				bash支持的引号：
						``:命令替换 将一个命令的输出作为另外一个命令的参数
						"":弱引用,可以实现变量替换 变量名到变量值的替换
						'':强引用，不完成变量替换
					
					

					  
		2.管道，重定向
		3.命令别名
		4.命令行编辑 
			光标跳转：ctrl+a 行首 
				  ctrl+e 行尾
				  ctrl+u 删除光标至命令行首的内容
				  ctrl+k 删除光标至命令行尾的内容
				  ctrl+d 删除光标所在的命令
				  ctrl+l 清屏

		5.命令行展开 
		6.文件名通配
		7.支持使用变量
		8.支持编程
24.文件名通配 globbing pathnames  #man 7 glob :查看文件名通配
	*  :匹配任意长度的任意字符
	?  :匹配任意一个字符
	[] :匹配指定范围内的任意单个字符
		[abc],[a-z],[A-Z],[0-9]，[0-9a-zA-Z]
		[:space:]:表示所有的空白字符的集合
		[:punct:]:表示所有的标点符号的集合
		[:lower:]:表示所有的小写字母的集合
		[:upper:]:表示所有的大写字母的集合
		[:alpha:]:表示所有的字母的集合
		[:digit:]:表示数字的集合 ls [[:digit:]]* :显示所有以数字开头的文件
		[:alnum:]:表示数字和大小写字母的集合

	[^]:匹配指定范围之外的任意单个字符 即不以指定的开头
	[^[:alpha:]]:非字母
	[[:alpha:]]*[[:space:]]*[[:alpha:]] a b
	[[:alpha:]]*[^[:alpha:]]:以字母开头以非字母结尾的
25.用户，组，权限
	安全上下文 secure context
	权限 r w x
	文件：
		r:可读，可以使用类似cat等命令查看文件内容
		w:可写，可以编辑或删除此文件
		x:可执行，executable,可以在命令提示符下当做命令提交给内核运行
	目录：
		r:可以对此目录执行ls以列出内部所有文件
		w:可以在此目录创建文件
		x:可以使用cd切换进此目录，也可以使用ls -l查看内部文件的详细信息，目录一般都有x权限
	rwx:
		0 000 ---：无权限
		1 001 --x: 执行
		2 010 -w-: 写
		3 011 -wx: 写和执行
		4 100 r--: 读
		5 101 r-x: 读和执行
		6 110 rw-: 读和写
		7 111 rwx: 读写执行
		
		755：rwxr-xr-x
	用户：UID, /etc/passwd 影子口令(密码)：/etc/shadow
	  组：GID, /etc/group  影子口令(密码): /etc/gshadow
	用户类别：
		管理员：UID 0
		普通用户: UID 1-65535
			系统用户:1-499
			一般用户:500-60000
	用户组类别：
		1.管理员组：
		  普通组
			系统组
			一般组
		2.私有组：创建用户时，如果没有为其指定所属的组，系统会自动为其创建一个与用户名同名的组
		  基本组：用户的默认组
		  附加组，额外组：默认组以外的组
	用户管理
		useradd userdel usermod passwd chsh chfn finger id chage 
		useradd -u UID 
			-g GID 基本组
			-G GID,... 附加组  useradd -G mygroup user3
			-c "注释信息" 
			-r 添加一个系统用户
			-d /path/to/directory 指定家目录  useradd -c "Tony Blare" -d /home/blare user4
			-M 没有家目录
			-s 指定用户默认的执行shell路径 useradd -s /sbin/nologin user5     切换 su user5
		userdel 
			-r 同时删除用户的家目录 默认不会删除家目录
		usermod 
			同useradd用法类似
			-L 锁定账号
			-U 解锁账号
		chsh  更改shell设置
		chfn  修改注释信息
	密码管理
	passwd [username]
		--stdin 标准输入读取密码 Linux哲学尽量不与用户交互 用管道的方式传递给passwd命令 echo '密码' | passwd --stdin user3
		-l 锁定账号
		-u 解锁账号
		-n 密码最短使用时间
		-x 密码最长使用时间
		-w 警告时间
		-i 非活动时间
		-d 删除账号密码 用户没有密码是不能登录的，Linux是禁止空密码登录
	pwck verify intgrity of password files 检查密码的完整性

		
		
		

			
		
	组管理
		groupadd groupdel groupmod gpasswd
		
		groupadd 
			-g GID
			-r 添加为系统组
		groupmod 
			-g GID
			-n 修改组名
		groupdel 删除组名
		
		gpasswd 给组加密码
		
		newgrp 登录到其他组
	
	
	
	chage     改变用户密码的过期时间
		-d 最近一次的修改时间
	    -E 过期时间
		-I 非活动时间
		-m 最短使用期限
		-M 最长使用期限
		-W 警告时间
		




	练习 
		1.创建一个用户mandriva 其ID号为2002，基本组为distro组ID为3003，附加组为linux
			# groupadd -g 3003 distro
			# groupadd linux
			# useradd -u 2002 -g distro -G linux mandriva
		2.创建一个用户fedora，其全名为Fedro Community 默认shell为tcsh
			# useradd -c "Fedro Community" -s /bin/tchs fedro
		3.修改mandriva的ID号为4004，基本组为linux,附加组为distro和fedora
			# usermod -u 4004 -g linux -G distro,fedora mandriva
		4.给fedora加密码，并设置其密码最短使用期限为2天，最长为50天
			# passwd -n 2 -x 50 fedora
		5.将mandriva的默认shell改为/bin/bash
			# usermod -s /bin/bash mandriva 
		6.添加系统用户hbase 且不允许其登录系统
	·	 	# useradd -r -s /sbin/nologin hbase
		
		
		
			
			
	权限管理
		chmod chgrp chown umask

		三类用户
			u 属主
			g 属组
			o 其他用户
			a 所有用户
		chown 改变文件属主(只有管理员可以使用此命令)
			# chown userowner file,...
				-R 修改目录及其内部文件 
				--reference=/path/to/somefile file,...  把file,...设定成与somefile同样的属主同时也改了属组	
			
		chgrp 改变文件属组 也只有管理员才可以使用此命令
			# chgrp groupname file,...
				-R 递归修改
		同时修改用户名和属组名
		chown username:groupname file,... 同时修改 chown :groupname file,...就只改组名
		chown username.groupname file,... 同上
		
		chmod 修改文件权限 
			1.可以修改三类用户的权限
				chmod 775 file/dir,... 注意位数不够时是从前面补0，例 chmod 75 file  就是075权限
					-R 递归修改文件下的所有文件
					--reference=/path/to/somefile file,... 
			2.也可以修改某类用户或某些用户权限 chmod user=mode file,...
				 chmod u=rwx /tmp/abc
				 chmod u=rwx,g=rw /tmp/abc 当不一样的时候用逗号隔开
				 chmod ug=rw /tmp/abc
				 chmod g=rx,o= /tmp/abc    省略既是对应位上没有权限
				 
			3.修改某类的用户某位或某些位权限
				 chmod user+/-mode file,...
				 chmod u-wx /tmp/abc
				 chmod u+x,g-x /tmp/abc
				 chmod a+x /tmp/abc  注a可以省略 chmod +x /tmp/abc
				 
		练习
			1.新建一个没有家目录的用户openstack
				# useradd -M openstack
			2.复制/etc/skel为/home/openstack
				# cp -r /etc/skel /home/openstack
			3.改变/home/openstack及其内部文件的属主属组均为openstack
				# chown -R openstack:openstack /home/openstack
			4./home/openstack及其内部文件，属组和属主和其他用户没有任何访问权限
 				# chmod -R go= /home/openstack
		验证操作成功 su -openstack
 		 
		手动添加用户hive 基本组为hive(5000),附加组为mygroup

		nano /etc/group   最后一行添加 hive:x:5000 在mygroup所在行添加hive
		nano /etc/passwd  最后一行添加hive:x:5000:5000:Hive:/home/hive:/bin/bash
		nano /etc/shadow  最后一行添加hive:!:16840:0:99999:7:::
		cp -r /etc/skel/ /home/hive
		chown -R hive:hive /home/hive
		chmod -R go= /home/hive
		openssl passwd 可以把密码生成秘钥 
			-1 :生成带加了8位杂质的秘钥 
		openssl passwd -1 -salt '12345678' ：生成秘钥$1$12345678$0ME5N6oDyoEAwUp7b5UDM/把它粘贴到/etc/shadow hive把!号替换 
		
		管理员的默认创建文件权限是644	文件夹是755
		普通管理员创建文件权限是664	文件夹是775
		
		umask: 遮罩码 root的遮罩码是0022 普通用户的遮罩码是0002  第一0表示特殊权限，参考37
		设定umask码 umask 022 修改之后只会在当前有效 退出后失效 在.bashrc中加上一行umask 022即可
		创建文件的权限是666-umask码 注意文件默认没有执行权限，如果算的结果中有执行权限时会自动加1  umask 023 试试 666-023=643 但是实际上是644
		创建目录的权限是777-umask码
		
		站在用户登录的角度来说，Shell的类型：
			1.登录式shell
				正常通常某终端登录
				su - username
				su -l username
			2.非登录的shell
				su username
				图形终端下打开命令窗口
				自动执行的shell脚本
		bash的配置文件
			全局配置 /etc/profile, /etc/profile.d/*.sh,以及/etc/bashrc
			个人配置 ~/.bash_profile, ~/.bashrc

		profile类的文件：设定环境变量  运行命令或脚本
		bashrc类的文件：设定本地变量 定义命令别名

		登录式shell如何读取配置文件？
			首先读取/etc/profile-->/etc/profile.d/*.sh -->~/.bash_profile -->~/.bashrc --> /etc/bashrc
		非登录式shell如何读取配置文件？
			首先读取~/.bashrc --> /etc/bashrc --> /etc/profile.d/*.sh

26./etc/passwd
	account:登录名
	password:密码
	UID
	GID
	comment:用户的额外信息
	Home Dir: 家目录
	Shell: 用户的默认shell
  /etc/shadow
	account：登录名
	encrypted passwrod:加密的密码
 /etc/shells : 指定了当前系统可用的安全shell
 /etc/login.defs
	


加密方法：
	对称加密：加密和解密使用同一个密码
	非对称加密，公钥加密：每个密码都成对加密，一个为公钥public key 一个为私钥secret key
	单向加密，散列加密：能加密不能解密  用于数据完整性校验  常用的有 MD5 Message Digest   SHA1:secure hash algorithm 
		 		1.不可逆
				2.雪崩效应 初始数据的微小改变将会引起结果的巨大变化 反逆破解
				3.定长输出
27.I/O重定向
	>:标准输出重定向 原有内容会被覆盖掉 而>>输出重定向会保留原有内容，追加输出
		     为了防止数据被覆盖 bash中有一个set命令 help set 中 -C开关关闭overwritten,+C打开
		     set -C：禁止对已经存在文件使用覆盖重定向 强制覆盖输出 则使用>|
		     set +C：关闭上述功能
	2>:错误输出重定向  ls /varr > /home/var.txt 但没有文件夹varr 此时/home/var.txt里没有内容
		      使用 ls /varr 2> /home/var.txt  则把错误输出写到文件中
		2>>：是使用追加的方式写入到文件中
		 
		ls -l /var > /home/var.txt 2> /home/err.out 正确则重定向到var.txt，错误则重定向到err.out 
	也可以  ls -l /var > /home/var.txt 2> /home/var.txt 一个文件不可能既是正确又是错误的,所以可以重定向到同一个文件里
		 
	&> :重定向标准输出或错误输出至同一个文件中
		以上命令就可以这样写
		ls /var &> /home/var.out  不管是标准输出还是错误输出都写到var.out下
	&>> :追加的方式


	<:标准输入重定向	
		而没有<<用法 <<：表示此处生成文档here document
	cat >> /home/sunyinhui/myfile.txt <<EOF	  把输入写入到文件中
28.管道:前一个命令的输出，作为另一个命令的输入  用于组合小命令完成复杂任务
	命令1 | 命令2 | 命令3 ...：把命令1的输出传递到命令2当做命令2的输入 甚至再传递到命令3
	echo 'hello world' | tr 'a-z' 'A-Z'
	cut -d: -f1 /etc/passwd | sort | tr 'a-z' 'A-Z' 
	
	命令tee :read from standard input and write to standard output and files 
		实现在终端输出也写入到文件
	echo 'hello world' | tee /home/sunyinhui/hello.out
	wc -l /etc/passwd | cut -d' ' -f1 ;  ' '表示空白字符
	
	练习：
		1.统计/usr/bin/目录下的文件个数
			# ls /usr/bin | wc -l : 注意ls不加-l参数 -l显示的第一行是total 45004 
		2.取出当前系统上所有用户的shell 要求 每种shell只显示一次 并且按顺序进行显示
			# cut -d: -f7 /etc/passwd | sort -u | wc -n
		3.显示/var/log/下所有文件的类型
			# file /var/log*
		4.取出/etc/inittab文件的第6行:先取前6行，再取最后一行
			# head -6 /etc/inittab | tail -1 
		5.取出/etc/passwd文件中的倒数第9个用户的用户名和shell,显示到屏幕上并将其保存到/tmp/users文件中
			# tail -9 /etc/passwd |head -1 |  cut -d: -f1,7 | tee /tmp/users
		6.显示/etc/下以pa开头的文件，并统计其个数
			# ls -d /etc/pa* | wc -l
		7.不使用文本编辑器，将alias cls=clear 一行内容添加至当前用户的.bashrc文件中
			# echo 'alias cls=clear' >> ~/.bashrc
29.grep：global  research expression 正则表达式  根据模式去搜索文本，并将符合模式的文本显示出来
 	 egrep,
	 fgrep fast grep :不支持正则表达式 
	
	Pattern:文本字符和正则表达式的元字符所组合起来过滤文本的匹配条件
	grep [options] pattern [file,...]
	grep [options] [-e pattern | -f file] [file,...]
	grep -i :忽略大小写
	     --color：加上颜色 加别名 alias grep='grep --color'
	     -v 显示没有匹配到的文本  --invert-match
         -o 只显示被匹配到的字符串
	     -E 扩展的正则表达式
	     -A n：After 连同显示匹配到所在行的下n行
	     -B n: Before                      上n行
	     -C n：Context                 上下各n行  context 上下文  
	通配符：
	* ：
	? :
	[]:
	[^]: 
	
	正则表达式 REGular EXPression REGEXP 
	   基本正则表达式 Basic expression
		元字符：
			.:任意单个字符
			[]:匹配指定范围内的单个字符
			[^]:匹配指定范围外的单个字符
			字符集合：[:digit:],[:lower:],[:upper:],[:punct:],[:space:],[:alpha:],[:alnum:]
				    grep '[[:digit:]]$' /etc/profile ：以数字结束的行
		字符个数：
			*：匹配其前面的字符任意次
			.*:任意长度的任意字符
			\?:匹配其前面的字符1次或0次   	
			\{m,n\}:匹配其前面的字符至少m次，至多n次
		位置锚定：
			^:锚定行首，此字符后面的任意字符必须出现在行首
			$:锚定行尾，此字符前面的任意字符必须出现在行尾
			^$:空白行
			\<或\b:锚定其后面的任意字符必须作为单词的首部出现
			\>或\b:锚定其前面的任意字符必须作为单词的尾部出现
			       \<root\> 就是在文本中查找root单词
		分组：
			\(\):
				ab*
				\(ab\)* :把ab当成一个整体
				 	He love his lover.
					She like her lover.
					He like his liker.
					She love her liker.
					
					
			向后引用
				\1:第一个左括号以及与之对应的右括号所包括的所有内容
				\2:第二个
				grep '\(l..e\).*\1r' test.txt		
	扩展正则表达式
		*:匹配其前字符任意次
		?:匹配其前字符1次或0次
		+:匹配其前字符至少匹配1次 相当于 \{1,\}
		{m,n}:不用加\	
		():分组 不加\
		| :或者， or  例如 C|cat 表示 C或者cat  | 整个左边或整个右边 
						   (C|c)at 表示要匹配Cat或者cat
		
	egrep '([1-9])'
	
	查找0-255
	egrep --color '(\<([0-9]|[1-9]|[0-9]|1[0-9][0-9]|2[0-9][0-9]|25[0-5])\>\.){3}\<([0-9]|[1-9]|[0-9]|1[0-9][0-9]|2[0-9][0-9]|25[0-5])\>'
	eg: ifconfig | egerp --color '(\<([0-9]|[1-9]|[0-9]|1[0-9][0-9]|2[0-9][0-9]|25[0-5])\>\.){3}\<([0-9]|[1-9]|[0-9]|1[0-9][0-9]|2[0-9][0-9]|25[0-5])\>'
	
	IPV4： A B C D E 
	A: 1-127
	B:128-191
	C:192-223
	
	IP地址匹配 
	
	

30.Shell编程

	脚本编程

	静态语言：编译型语言
		强类型 变量 变量在使用前，必须事先声明，甚至还需要初始化。
		事先转换成可执行格式
		C C++ JAVA 
	动态语言：解释型语言 on the fly
		弱类型 变量用时声明，甚至不区分类型
		边解释边执行
		PHP, shell, python, perl
	面向过程：
	面向对象：
	变量类型：事先确定数据的存储格式和长度
	变量: 内存空间，命名
	内存：编址的存储单元
31. Bash变量类型
	环境变量
	本地变量 局部变量
	位置变量
	特殊变量
	
	本地变量 VarName=Value  即可，在整个bash脚本中都可以使用。 set VarName=Value  set 可以省略 
	引用变量 $(VarName) :括号可以省略 ，在不至于变量名称混淆时可以省略。
			eg: #ANIMAL=pig
				#echo "There are some $ANIMALs."   最后输出There are some .
				#echo "There are some ${ANIMAL}s." 最后输出There are some pigs.
				#echo 'There are some ${ANIMAL}s.' 最后输出There are some $(ANIMAL)s.
	
		bash支持的引号：
		``:命令替换
		"":弱引用,可以实现变量替换 变量名到变量值的替换
		'':强引用，不完成变量替换
	
	局部变量 作用域只对当段代码有效
			加上local即可
			local VarName=Jerry 
		
	环境变量：作用域为当前shell进程及其当前子进程
			export VarName=Value
			或者
			VarName=Value
			export VarName
			
	
		脚本在执行时会启动一个子Shell进程
			命令行中启动的脚本会继承当前shell环境变量：
			如果是系统自动执行的脚本(非命令行启动)就需要自我定义需要各环境变量
	位置变量 
		$1,$2,... :位置变量是引用脚本的参数
		shift  如果参数太多，使用$1-$10,就太麻烦。shift就是当执行过第一个参数后，shift剔除第一个，然后第二个变成第一个参数，依次类推.
			   shift N 剔除N个 默认剔除1个
			#!/bin/bash
			echo $1
			shift
			echo $1
			shift
			echo $1
			
			bash shift.sh /rpp /rop /ddd
			就会输出 /rpp
					 /rop
					 /ddd
		help shift
			
				shift: shift [n]
				Shift positional parameters.
				
				Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is
				not given, it is assumed to be 1.
				
				Exit Status:
				Returns success unless N is negative or greater than $#.
		脚本，写一个脚本
			给脚本传递一个参数(整数)
			显示此两者之和，之积。测试给的参数够不够
				  1 #!/bin/bash
				  2 # 计算两个参数之和，之积，要测试参数个数
				  3 # 
				  4 if [ $# -lt 2 ]; then
				  5     echo "the arg must be two"
						echo "Usage: arg1, arg2"
				  6     exit
				  7 fi
				  8 
				  9 echo "The Sum is :$[$1 + $2]"
				  10 echo  "The prod is:$[$1*$2]"
		
		例如可以查看三个文件
			cat /etc/inittab /etc/fstab /etc/issue
			$1:对应的是/etc/inittab参数
			$2:对应的是/etc/fstab参数
			$3:对应的是/etc/issue参数
		练习 写一个脚本 filetest.sh
			能接受一个参数(文件路径)
				判断：此参数如果是一个存在的文件，就显示"OK"，否则就显示"No Such File"		
				  1 #!/bin/bash
				  2 #
				  3 if [ -e $1 ]; then
				  4     echo "OK"
				  5 else
				  6     echo "No such file"
				  7 fi 
		bash filetest.sh /etc/inittab  :No such file
		bash filetest.sh /etc/profile : Ok
		注意 当不给参数时，会输出Ok，所以要考虑这种没有给参数的情况
				  1 #!/bin/bash
				  2 #
				  3 echo $#  #显示参数的个数
				  4 echo $*  #显示参数列表
				  5 echo $@  #显示参数列表
				  6 
				  7 if [  $# -lt 1 ]; then
				  8     echo "Usage: bash filetest.sh arg1 [arg2...] "
				  9     exit 1
				 10 fi  
				 11 
				 12 if [ ! -e $1 ]; then
				 13     echo "No such file"
				 14     exit 1
				 15 else
				 16     echo "Ok"
				 17 fi
		

	
	特殊变量
		$?：保存上一个命令的执行状态返回值，有时只关心程序的状态结果
		程序执行完之后，可能有两个返回值
				1. 程序执行结果
				2. 程序状态返回代码(0-255)
					0:正确执行
					1-255:错误执行。系统预留了1,2,127 有特殊意义 
		$#: 参数的个数 
		$*：参数列表
		$@：参数列表
		
		输出重定向
		>
		>>
		2>
		2>>
		&>
		&>>
		/dev/null:设备，软件设备， bit bucket 位桶，能把所有的吞下去，吃人不吐骨头， 数据黑洞 
		所以把结果重定向到/dev/null上 ，结果就不会显示出来
		eg: ls /var &> /dev/null  
			有时不关心输出结果，只关心状态结果
			echo $?  查看是否成功 
			#sunyinhui@slave1:/root$ echo $?
			#0
			#sunyinhui@slave1:/root$ ls /varr
			#ls: cannot access /varr: No such file or directory
			#sunyinhui@slave1:/root$ echo $?
			#2
			
	撤销变量
		unset VarName 
	
	查看当前shell中变量
		set 
	查看当前shell环境变量 
		printenv
		env
		export
		
	shell中变量的值默认是字符串类型，不能做算术运算的
		A=2
		B=3
		C=$A+$B
		echo $C
	
	脚本是命令的堆砌，按照实际需要进行堆砌，结合命令流程控制机制实现的源程序
	
32. 条件测试类型：
			整数测试
			字符测试
			文件测试
			
	条件测试的表达式：
			[ expression ] :注意 中括号两边要有空格，否则是语法错误
		或
			[[expression]]
		或   test命令 test expression
	
	整数比较：
		-eq：等值比较：	 equal测试两个整数是否相等； 比如 $A -eq $B  
		-ne: 不等值比较：not equal测试两个整数不等的， 不等为真，等则为假
		-gt: 大于比较：  greater than测试一个数是否大于另一个数，大于为真，小于等于为假
		-lt:小于比较：	 lesser than 测试一个数是否小于另一个数，小于为真，否则为假
		-ge 大于或等于
		-le 小于或等于

	文件测试
		-e File ：表示文件是否存在
		-f File ：测试文件是否为普通文件
		-d File ：测试指定路径是否为目录的
		-r File ：测试当前用户对指定文件是否有可读权限
		-w
		-x
		
		[ -e /etc/passwd ]
		
	字符(串)测试
		== ：测试相等 一个或两个等于号  A=hello 
							   B=hi
							   [ $A = $B ] 或 [ '$A' == '$B' ] 或 [[ '$A' == '$B']]  注意空格
		!=  :测试不等
		>  : 测试大于
		<  ：测试小于
		-n string :测试指定字符串是否为空，空则真，不空为假
		-z string :测试指定字符串是否为不空，不空为真，空则为假
		
		
		
	命令间的逻辑关系：短路操作 ，当结果已经出现，以后的就不执行
		逻辑与：&&一假即假   id sunyinhui &> /dev/null  && echo "Hello！"
		逻辑或：||一真为真   id user || useradd user
	
	如果用户不存在就添加用户：! id user && useradd user 
	如果用户已经存在，就显示用户已存在，否则，就添加此用户
		id user && echo "user is exist" || useradd user 
	如果用户不存在，就添加，并且给密码为用户名，否则，显示其已经存在
		! id user &&　useadd user && echo "user" | passwd --stdin user || echo "user exists."
	
	如果/etc/profile 文件的行数大于30，就输出 "Large file" 
	[ `wc -l /etc/profile | cut -d' ' -f1` -gt 30  ] && echo "Large file"
	
		
	变量名称  
		1.字母、数字、下划线，不能以数字打头，
		2.不应跟系统中已有的环境变量重名
		3.要做到见名知意

	
	练习，写一个脚本，完成以下要求：
		1. 添加3个用户user1,user2,user3 但要先判断用户是否存在，不存在而后再添加；
		2. 添加完成后，显示一共添加了几个用户，当然，不能包括因为事先存在而没有添加的
		3. 最后显示当前系统上共有多少个用户
			
		  1 #!/bin/bash
		  2 
		  3 ! id user1 &> /dev/null && useradd user1 && echo "user1" | passwd --stdin user1 &> /dev/null || echo "user1 exists."
		  4 ! id user2 &> /dev/null && useradd user2 && echo "user2" | passwd --stdin user2 &> /dev/null || echo "user2 exists."
		  5 ! id user3 &> /dev/null && useradd user3 && echo "user3" | passwd --stdin user3 &> /dev/null || echo "user3 exists."
		  6 USER=`wc -l /etc/passwd | cut -d' ' -f1 `
		  7 
		  8 echo $USER users.
	练习 写一个脚本，完成以下要求：
		1.如果其UID为0，就显示此为管理员
		2.否则，就显示其为普通用户
		
		  1 #!/bin/bash
		  2 # UID为0，就显示为管理员，否则就显示为普通用户
		  3 #
		  4 
		  5 NAME=user1
		  6 USERID=`id  -u $NAME`
		  7 [ $USERID -eq 0 ] && echo "Admin" || echo "Common user."
	
	条件判断，控制结构：
			注意 当then与if在同一行 ; 不能省略。若then在下一行时，;可以省略。
		单分支的if语句
				if 判断条件; then   
					statement1
					statement2
					.....
				fi
		双分支的if语句：
				if 判断条件; then 
					statement1
					statement2
					....
				else
					statement3
					statement4
					....
				fi
		多分支的if语句
			if 判断条件1; then
				statement1
				...
			elif 判断条件2; then
				statement2
				...
			elif 判断条件3; then
				statement3
				...
			else 
				statement4
				...
			fi
			
	bash 有测试脚本有没有语法错误的功能
		bash -n 脚本名称
		bash -x 脚本 ：显示执行的语句
		
		
	
	练习 写一个脚本
		判断当前系统上是否有用户的默认shell为bash
		如果有，就显示有多少个这类用户，否则，就显示没有这类用户
		grep "\bbash$" /etc/passwd &> /dev/null  
		RETVAL=$? # 获得上一行执行状态结果。
		if [ $RETVAL -eq 0 ] ; then
			grep "\bbash$" /etc/passwd | wc -l
		echo 
			echo "No such user."
		fi
		
			1 #!/bin/bash
			2 # 
			3 grep "\bbash$" /etc/passwd &> /dev/null
			4 RETVAL=$?
			5 if [ $RETVAL -eq 0 ]; then
			6    users=` grep "\bbash$" /etc/passwd | wc -l`           # 命令的引用
			7    echo "Default shell is bash there  are $users users."
			8 else 
			9     echo "No such user."
			10 fi
				
		提示：
			`引用` 一个命令的执行结果，要使用命令引用，比如 users=`grep "\bbash$" /etc/passwd | wc -l`
			使用一个命令的执行状态结果，要直接执行此命令，一定不能引用，比如 if id user 一句中的id命令就一定不能加引号
			如果想把一个命令的执行结果赋给某变量，要使用命令引用，比如 userid=`id -u user`
			如果想要把一个命令的执行状态结果保留下来，并作为命令执行成功与否的判断标准，则需要先执行此命令，而后引用其状态结果，如
				id -u user
				RETVAL=$?
				此句，绝对不可写为 RETVAL=`id -u user`
				
	练习 写个一个脚本
		判断当前系统上是否有用户的默认shell为bash；
		如果有，就显示其中一个的用户名，否则，就显示没有这类用户
			  1 #!/bin/bash
			  2 # 
			  3 grep "\bbash$" /etc/passwd &> /dev/null
			  4 RETVAL=$?
			  5 if [ $RETVAL -eq 0 ]; then
			  6    AUSER=`grep "\bbash$" /etc/passwd | head -1 | cut -d: -f1`
			  7    echo  " $AUSER  is the such user."
			  8 else
			  9     echo "No such user."
			 10 fi
	
	练习 写一个脚本
		给定一个文件，比如/etc/inittab
		判断这个文件中是否有空白行
		如果有，就显示其空白行数，否则，显示没有空白行
			  1 #!/bin/bash
			  2 #判断是否存在空白行，若有，就显示行号，否则就显示没有空白行
			  3 # 
			  4 
			  5 grep "^$" /etc/profile &> /dev/null
			  6 space=$?
			  7 if [ $space -eq 0 ]; then
			  8     Num=`grep '^$' /etc/profile | wc -l `
			  9     echo "the space is local at $Num"
			 10 fi
        改进：若文件不存在，就没有必要继续执行 
			  1 #!/bin/bash
			  2 # 改进，若文件不存在，就没有必要继续执行
			  3 FILE=/etc/profile
			  4 if [ ! -e $FILE ]; then
			  5     echo "No Such the $FILE "
			  6     exit 1
			  7 fi
			  8 
			  9 if grep "^$" $FILE &> /dev/null;then
			 10     echo "Total blank lines: `grep "^$" $FILE | wc -l ` ."
			 11 else
			 12     echo "No blank lines."
			 13 fi

		
		
		
	练习 写一个脚本
		给定一个用户，判断其UID和GID是否一样
		如果一样，就显示此用户为“good guy”， 否则 就显示此用户为“bad guy”
			  1 #!/bin/bash
			  2 # 判断用户的UID和GID是否一致
			  3 User=sunyinhui
			  4 UserUID=`id -u $User`
			  5 UserGID=`id -g $User`
			  6 if  [ $UserUID -eq $UserGID ]; then
			  7     echo "good guy"
			  8 else
			  9     echo "bad guy"
			 10 fi
		进一步要求，不使用id命令获得其id号 查看 /etc/passwd
		
		
			
	练习 写一个脚本
		给定一个用户，获取其密码警告期限；
		而后判断 用户密码使用期限是否已经小于警告期限； 计算方法，最长使用期限减去已经使用的天数即为剩余使用期限。
		如果小于，则显示“Warning”;否则 就显示“OK”
			提示：算术运算的方法 $[$A-$B] 表示变量A的值减去变量B的值的结果。
			  1 #!/bin/bash
			  2 # 获得警告期限
			  3 # 
			  4 User=sunyinhui
			  5 W=`grep  "$User:" /etc/shadow |cut -d: -f6 `
			  6 S=`date +%s`
			  7 T=`expr $S/86400`
			  8 L=`grep "$User:" /etc/shadow |cut -d: -f5`
			  9 N=`grep "$User:" /etc/shadow |cut -d: -f3`
			 10 SY=$[$L-$[$T-$N]]
			 11 
			 12 if [ $SY -lt $W ]; then
			 13     echo "Warning"
			 14 else
			 15     echo "Ok"
			 16 fi  
			
			
			
			
			
	
	练习 写一个脚本
		判定命令历史中历史命令的总条目是否大于1000，如果大于，则显示“Some command will gone”，否则显示“OK”
		注意 history | wc -l : history 只保留1000命令，所以要在/root/.bash_history中查看。cat /root/.bash_history | wc -l
			  1 #!/bin/bash
			  2 # 判断history条目是否大于1000
			  3 
			  4 HISTORY=`cat /root/.bash_history | wc -l`  # history | tail -1 | cut -d' ' -f2 也可以取出行号
			  5 if [ $HISTORY -gt 1000 ]; then
			  6     echo "Some command will gone"
			  7 else
			  8     echo "OK"
			  9 fi
		
		

	在shell中进行加减乘除运算
		A=3
		B=6
		1.let命令  help let
				let expression   如 let C=$A+$B  echo $C
		2.$[expression]
			    D=$[$A+$B]  echo $D
		3 $((算术运算表达式))
				E=$(($A+$B))  echo $E
		4 expr 算术运算表达式 ；注意表达式中各操作符及运算符之间要有空格，而且要使用命令引用
			C=`expr $A + $B`
		
	 exit 退出脚本 
		exit n : 当n取非0的整数。
		如果脚本没有明确定义退出状态码，那么，最后执行的一条命令的退出码即为脚本的退出状态码
		
		
	练习 写一个脚本
		给定一个文件：
		如果是一个普通文件，就显示之
		如果是一个目录，亦显示之
		否则，此为无法识别的文件
		#!/bin/bash
		FILE=/etc/passwd
		if [ ! -e $FILE ];then
			echo "$FILE is not exist. "
			exit 1
		elif [ -d $FILE ]; then
			echo "$FILE is a directory"
		elif [ -f $FILE ];then
			echo "$FILE is a file."
		else 
			echo "can not recongrection the $FILE "
		fi
	bash变量的类型
		本地变量(局部变量)
		环境变量 
	
	
33. sed 流编辑器  awk 
	sed stream EDitor 纯ASCII文本的
		行编辑器 把一行读到内存中，在内存空间与给定的模式匹配，若匹配，也叫作sed的模式空间，在模式空间上进行操作。 而后将模式空间中的内容显示出来。
		默认情况下，不编辑原文件，仅对模式空间上的数据做处理
		
	sed [options]'AddressCommand' file,...  :Address 指定对那些行做出处理，Command命令做出操作。在Address 和 Command 之间不需要添加空白字符。
			options:
						-n :静默模式 即为 不显示模式空间上的内容
						-i :直接在原文件中修改 注意系统文件的修改  最好先做备份
						-e Script -e Script ...: 支持同时执行多个脚本。 脚本的含义就是'AddressCommand'
						-f File: 读取文件，执行文件中的命令
									sed -f /path/to/script file  注意可以把 -e后的S多个Script写在一个脚本中
						-r :表示使用扩展的正则表达式
						
		Address：
				1、StartLine,EndLine :起始行，结束行 比如 1,100   
				   $:最后一行
				   $-1:倒数第二行   
				2、/RegExg/ 正则表达式 例如 /^root/ 就是找文件中以root开头的行  
					注意 要用双斜线引起来
				3、/Pattern1/,/Pattern2/ 表示从第一次被模式1匹配的行开始，到第一次被模式2匹配的行结束
				4、LineNumber 精确到某行
				5、StartLine,+N ：从StartLine开始，向后的N行
		Command：单引号，双引号都可以
				d: delete 删除符合条件的行。 sed "3,$d" /etc/fstab    
											 sed "/root/d" /etc/fstab
											 sed "1,+2d" /etc/fstab
					删除以/开头的行 需要转义
											 sed "/^\//d" /etc/fstab  
				p: print 显示符合条件的行
											 sed "/^\/p/" /etc/fstab  显示以/开头的行  注意会显示两次
											 sed -n '/^\//p' /etc/fstab 静默模式显示匹配到的行
				a: add 在匹配到的行后面新增一行  \string 在指定的行后面追加新行，内容为string
											 sed '/^\//a \#hello world' /etc/fstab   在匹配的模式下添加一行
											 sed '/^\//a \#hello world\n# hello linux' /etc/fstab 在匹配的模式下添加两行
																	  \n ：实现换行
				i: insert 在指定的行前面添加新行  \string 内容是string
											sed "/^#/i \hello world" /etc/fstab
				r File :将指定的文件添加到匹配到的行后面 
											sed '1,2r /etc/issue' /etc/fstab  在第一行和第二行后面添加/etc/issue 文件中的内容
				w File ：将指定范围内的内容所在的行另存至指定的文件中。
											sed '/root/w /tmp/root.txt' /etc/fstab 
												将文件中/etc/fstab包含root的行写入到/tmp/root.txt文文件中
				s/pattern/string/ :查找并替换 将匹配到的模式pattern替换为指定的string	注意 有三个斜线 ，不仅限于斜线，还可以使用#和@
									默认只替换每行中第一次被匹配到的模式
										s/pattern/string/修饰符
										修饰符 g: 全局替换
											   i: 忽略字符大小写
											   
													   
									sed 's/root/ROOT/' /etc/fstab 
									
									's/^\//#/' /etc/fstab
									sed 's/\//#/' /etc/fstab  没有全局替换
									sed 's/\//#/g' /etc/fstab
							
								s### 不需要转义 注意 pattern和string中不要出现#号 ,如遇#号使用@ sed  's@/@#@g' /etc/fstab
								s@@@ 不需要转义  同上 
					向后引用 
							test.txt  
									i  like her 
									she is my love
						    查找l..e 然后替换成l..er
									sed 's#\(l..e\)#\1r#g' test.txt
					&: 引用模式匹配整个串 
									sed 's#l..e#&r#g' test.txt

									root@slave1:~# grep '\(l..e\).*\1r' test.txt
									He love his lover
									root@slave1:~# sed  's#\(l..e\)#\1r#g' test.txt      
									He lover his loverr
									She liker her loverr

									root@slave1:~# sed 's#l..e#&r#g' test
									testif2.sh  testif.sh   test.txt    
									root@slave1:~# sed 's#l..e#&r#g' test.txt 
									He lover his loverr
									She liker her loverr
									
									
						把live->Live love->Love
									sed 's#l\(..e\)#L\1#g' test.txt
 									
							root@slave1:~# sed 's#l\(..e\)#L\1#g' test.txt
							He Love his Lover
							She Like her Lover
			
				把 命令history显示的行首空格去掉 
							history | sed 's#^[[:space:]]*##g' :可以删除行首的任意空白字符
							history | sed 's#^[[:space:]]*##g' | cut -d' ' -f1
	sed练习 
		1. 删除/etc/grub.conf 文件中行首的空白符
			sed -r 's@^[[[:space:]]+@@g' /etc/grub.conf
		2. 替换/etc/inittab文件中'id:3:initdefault:'一行中的数字为5
			sed 's@\(id:\)[0-9]\(:initdefault\)@\15\2@g' /etc/inittab
		3. 删除/etc/inittab文件中的空白行
			sed '/^$/d' /etc/inittab
		4. 删除/etc/inittab文件中开头的#号
			sed 's@^#@@g' /etc/inittab
		5. 删除某文件中开头的#号，及后面的空白字符，但要求#号后面必须有空白字符
			sed -r 's@^#[[:space:]]+@@g' /etc/inittab
		6. 删除某文件中以空白字符后面跟#号开头的行中，开头的空白字符及#
			sed  -r 's@^[[:space:]]+#@@g' /etc/inittab
		7. 取出一个文件路径的目录名称
			echo '/etc/rc.d' | sed -r 's@^(/.*/)[^/]+?@\1@g' 
			其中 rc.d叫作基名
			echo '/etc/rc.d' | sed -r 's@^/.*/([^/]+?)@\1@g' 
		
	练习 
	
		0 写一个脚本 
		  传递一个参数给脚本，如果参数为q Q quit Quit，就退出脚本，否则，就显示用户的参数
				  1 #!/bin/bash
				  2 if [ $1 == '[q Q quit Quit]' ]; then
				  3     exit
				  4 else
				  5     echo $1
				  6 fi
		  
		  
		  
	    1 传递一个用户名参数给脚本，判断此用户的用户名跟基本组的组名是否一致，并将结果显示出来
		字符串比较 
				  1 #!/bin/bash
				  2 # 测试用户
				  3 if ! id $1 &> /dev/null; then
				  4     echo "No Such user."
				  5     exit 10
				  6 fi  
				  7 
				  8 if [ `id -n -u $1` == `id -n -g $1` ]; then
				  9     echo 'conform'
				 10 else
				 11     echo 'not conform'
				 12 fi
						
						
		
		
		2 传递三个参数给脚本，第一个为整数，第二个为算术运算符，第三个为整数，将计算结果显示出来，要求保留两位整数，行如： ./calc.sh 5 / 2 
			提示：将参数传递给bc  scale=2 保留两个小数
		    	echo 'scale=2;111/22;' | bc
			或
				bc <<< "scale=2;111/22;"
			
		
		3 传递3个参数给脚本，参数为用户名，将这些用户的账号信息提取出来后放置于/tmp/testusers.txt文件中，并要求每一行行首有行号。
		
		
		4 写一个脚本 判断当前主机的cpu生产商，其信息在/proc/cpuinfo 文件中vendor id 一行中
	      如果其生产商为AuthenticAMD，就显示其为AMD公司
		  如果其生产商为AuthenticIntel，就显示其为Intel公司， 否则就显示为非主流公司
		
		5  写一个脚本，给脚本传递三个整数，判断其中的最大数和最小数，并显示出来
			
	循环 :进入循环、退出循环 
		1 for 
		2 while
		3 until
		
		for循环通过遍历列表来循环的 
		
		for 变量 in 列表; do     或    for  变量 in 列表; 
			循环体                     do  
		done                                循环体
									   done 
		
		如何生成列表：
				{1..100}  两个点
				seq 起始数， 步进长度， 结束数
		
		声明一个变量 
			declare -i SUM=0
					-i integer 整数
					-x export 将变量声明为环境变量
		从1加到100：
				  1 #!/bin/bash
				  2 declare -i SUM=0
				  3 
				  4 for I in {1..100};do 
				  5     SUM=$[$SUM+$I]
				  6 done
				  7 
				  8 echo $SUM
				  
		向系统中的每个用户说Hello 
				  1 #!/bin/bash
				  2 # 向系统中的每个用户说hello
				  3 
				  4 declare -i LINES=`wc -l /etc/passwd |cut -d' ' -f1`
				  5 
				  6 for I in `seq 1 $LINES`;do
				  7   Str=` head -n $I /etc/passwd | tail -1 | cut -d: -f1`
				  8   echo "hello $Str"
				  9   done		
		
		
34 Vim
    Vi : Visual Interface 
	Vim : Visual Interface Improved  vi增强版
		全屏编辑器 模式编辑器，模式之间可以转换
	Vim模式 默认处于命令模式
		命令模式：
		输入模式：
		末行模式：
	模式转换：
		命令模式->输入模式
			输入模式
				i:当前光标所在字符前面，转换为输入模式
				a:当前光标所在字符后面，转换为输入模式
				o:当前光标行的下面，新建一行，并转换为输入模式
				I：在当前光标所在行的行首，转换为输入模式
				A: 在当前光标所在行的行尾，转换为输入模式
				O: 在当前行的上方，新建一行，并转换为输入模式
		输入模式->命令模式
				ESC 
		命令模式->末行模式  (只能从命令模式进入末行模式，不能从输入模式进入末行模式)
			末行模式
				：
				:nd 	删除第n行
				:n,md	删除n-m行
				:.,+nd 	删除当前行及其下n行
				:.,nd	删除当前行到第n行
				:! ls /etc
				
				其中：
					.：		表示当前行
					$：		最后一行
					$-n:	倒数第n行
					+n:		向下n行
					
				
				
				
		末行模式->命令模式
				ESC（当末行模式有参数时，需要两个ESC）
				
			
	
	一 打开文件	
			# vim /path/to/file 打开单个文件
			vim +n  /path/to/file    直接打开文件的第n行
			vim + /path/to/file      直接打开文件的尾部
			vim +/pattern file      打开文件，第一次定位到匹配到模式的行首
	
	二 关闭文件
			1. 在末行模式下关闭文件
				w :	保存，对于普通用户只有读权限是不起作用的。
				w!: 强行保存，只对管理员而言。
				q :	不保存，退出
				wq:	保存并退出
				x : 保存并退出
				q!: 强行退出
			2. 在命令模式下关闭文件
				ZZ：保存并退出
	
	三 移动光标 在命令模式下
			1. 逐字符移动光标：
				h:向左
				l:向右
				j:向上
				k:向下
					注意 nh:向左移动n个字符
						 nl:向右移动n个字符
						 nj
						 nk
			2. 逐单词移动
				w:移动至下一个单词词首
				e:移动至下一个单词词尾
				b:移动至上一个单词词首
					注意 nw ne nb
			3. 行内跳转
				0:数字0 跳至行首 绝对行首
				^:跳至行首 相对行首，第一个非空白字符
				$:行尾
			4. 句和段之间跳转
				():移动光标到下一个句子 )，移动光标到上一个句子(
				{}:移动到段首{，移动到段尾}
			5. 行间跳转
				nG :跳转至第n行
				G  ：最后一行
				在末行模式下，直接给出行号即可。跳到第n行
				
	四 翻屏操作
		ctrl + f : 向下翻屏
		ctrl + b : 向上翻屏
		ctrl + d ：向下翻半屏 down
		ctrl + u : 向上翻半屏 up 
	
	五  删除单个字符
		x: 删除光标所在的单个字符，支持nx操作，删除光标所在处，及其以后的n个字符
		
	六 删除命令  :d 跟跳转命令结合使用，还支持 ndw 
		dd：删除光标所在行， 
		ndd:从当前光标所在行在内的n行
		d$: 删除光标所在位置直至行尾
		d^: 删除光标所在位置直至行首
		d0: 同上
		dw：删除光标所在位置的下一个单词
		de: 
		db：
		
	七 复制命令 y  用法同d 
		yy 		复制一行
		3yy		复制3行
		
	八 粘贴命令 p/P
		小写p: 	如果删除或复制为整行内容，粘贴到光标所在行的下行
				如果删除或复制为非整行内容，粘贴至光标所在字符的后面
		大写P：	如果删除或复制为整行内容，粘贴到光标所在行的上行
				如果删除或复制为非整行内容，粘贴至光标所在行的前面
		
	九 撤销命令  u: undo 
		u 
		连续操作可以连续撤销
		或 
		nu : 直接撤销至上n次便捷操作
		
		撤销自己的撤销操作 Ctrl + r 
			当撤销到一定的位置，发现自己多撤销了，就使用ctrl + r 还原最后一次的撤销操作
	
	十 修改：先删除内容，在转换为输入模式 ：替换修改
		c: change  用法同d
	
	十一 替换 R和r
			r+替换字符：当在替换单个字符时用
			R+ 替换 ：进入替换模式，可以连续替换
	
	十二  重复前一次的操作
			. : 重复前一次的重复操作
			
	十三  可视化模式 V v  可以选中光标所滑过的所有字符
			v ： 按字符选取
			V :	 按矩形选取
	
	十四 查找  支持正则表达式
			/pattern  ：从文件首部向尾部查找
			?pattern  :
	
	十五 替换 s
		在末行模式下使用s命令，用法同sed 
		:s/if/IF/g
		1,$:从第一行到最后一行
		%  :同上 表示全文
		
		练习 ： 将/etc/yum.repos.d/server.repo文件中的ftp://instructor.example.com/pub替换为http://172.16.0.1/yum
					vim /etc/yum.repos.d/server.repo
					:%s#ftp://instructor.example.com/pub#http://172.16.0.1/yum#g
			
	十六  使用VIM编辑多个文件
		vim file1 file2 :打开多个文件，默认只显示第一个文件。
			在末行模式下
				:next  切换到下一个文件
				:prev  切换到上一个文件
				:last  切换到最后一个文件
				:first 切换到第一个文件
			:q 		退出当前文件
			:qall 	退出所有文件
			:qa     同上
		 
	十七  分屏显示一个文件 窗口拆分
			水平拆分窗口
						ctrl + w, s ：			水平拆分窗口
						ctrl + w, 向下箭头 ：   切换到下一个拆分窗口
						ctrl + w, w ：        	同上
			垂直拆分窗口
						ctrl + w, v： 			垂直拆分窗口
						
			注：在窗口间切换 
						ctrl + w, 上下左右箭头
			:q  	只能退出当前窗口
			:qa 	退出所有窗口
			:qll 	同上
			
	十八  分窗口显示多个文件  (方便在文件中进行数据交换)
			vim -o file1 file2 
				-o  水平显示
				-O  垂直显示
			切换窗口同上
			
	十九  将当前的部分内容另存为另外文件
			:w /path/to/file			将全部内容保存至file 
			:addr1,addr2w /path/to/file 将指定行保存至file
			
	二十  将另外一个文件的内容填充在当前文件中
		    :r  /path/to/file
	
	二十一 跟shell交互
			:! Command    直接输入命令运行
						  回车后，进入vim编辑器
	
	二十二 高级话题
			1	显示或取消行号
				:set number  显示行号 
				:set nu		 显示行号
				:set nonu	 取消行号
			2	忽略大小写
				:set ignorecase  忽略大小写
				:set ic			 同上
				:set noignorecase 不忽略大小写
				:set noic         同上
			3	设定自动缩进
				:set autoindent
				:set ai
				:set noai      取消
			4	查找到的文本设置高亮显示或取消高亮显示
				:set hlsearch	  高亮显示 high light
				:set nohlsearch   取消高亮显示
			5	语法高亮显示(语法着手)
				:syntax on  打开语法高亮显示
				:syntax off 关闭语法高亮显示
		以上只对当前shell有效，若要永久有效修改配置文件
		
	二十三 	配置文件			
				1	全局所有用户
							/etc/vimrc
				2	当前用户
							~/.vimrc   隐藏文件
		查看vim帮助
				vimtutor
		
		
	练习写脚本
		1.	添加10个用户user1到user10，密码同用户名，但要求当用户不存在时才添加
				  1 #!/bin/bash
				  2 #添加10个用户
				  3 #
				  4 for I in {1..10}; do
				  5     if id user$I &> /dev/null ; then
				  6         echo "user$I exists."
				  7     else
				  8         useradd user$I
				  9         echo "user$T" | passwd --stdin user$I &> /dev/null
				 10         echo "add user$I sucess"
				 11     fi
				 12 done
			
			删除：
				  1 #!/bin/bash
				  2 # 删除10个用户
				  3 # 
				  4 
				  5 for I in {1..10} ; do
				  6     if id user$I &> /dev/null ;then
				  7         userdel -r user$I
							echo "delete user$I finished"
				  
				  8     else
				  9         echo "user$I not exists."
				 10     fi
				 11 done				
							
		扩展： 接收一个参数
							--add：添加10个用户
							--del：删除10个用户
										  1 #!/bin/bash
										  2 # 接收一个参数
										  3 # add 添加
										  4 # del 删除
										  5 echo $1
											if [ $# -lt 1]; then
												echo "Usage: with arg"
												exit 7
											fi
										  6 if [ $1 == '--del' ]; then
										  7     for I in {1..10} ;do
										  8         if id user$I &> /dev/null ;then
										  9             userdel -r user$I
										 10             echo "delete user$I finised."
										 11         else
										 12             echo "user$I not exists."
										 13         fi  
										 14     done
										 15 elif [ $1 == '--add' ] ;then
										 16     for I in {1..10} ;do
										 17         if id user$I &> /dev/null ;then
										 18             echo "user$I exists." 
										 19         else
										 20             useradd user$I
										 21             echo "user$I" | passwd --stdin user$I &> /dev/null
										 22             echo "Add user$I sucess."
										 23         fi  
										 24     done
										 25 else
										 26     echo "the arg is not del or add"
										 27     exit 8
										 28 fi 						
		扩展：接收多个参数 只操作列表中指定的用户 注意是逗号隔开，当是空格隔开时，可以使用$1...$n来获取参数。
																  当是逗号时，当做一个字符串，然后使用sed 把逗号分割转换成列表
						--add user1,hello, user2,world 
						--del user1,hello, user2,world

									  1 #!/bin/bash
									  2 # 使用逗号分隔时
									  3 # --add hive,hello,world
									  4 # --del hive,hello,world
									  5 # 
									  6 #
									  7 echo $1
									  8 # 使用sed 把 $1 转换成列表
									  9 echo $1 | sed 's/,/ /g'
									 10 
									 11 if [ $1 == '--add' ];then
									 12   for I in `echo "$2" | sed 's#,# #g'`;do
									 13       if id $I &> /dev/null ;then
									 14           echo "$I is exists."
									 15       else
									 16           useradd $I
									 17           echo "$I" | passwd --stdin $I &> /dev/null
									 18           echo "add $I sucess."
									 19       fi
									 20   done
									 21 elif [ $1 == '--del' ];then
									 22     for I in `echo "$2" | sed 's#,# #g'`;do
									 23         if id $I &> /dev/null;then
									 24             userdel $I
									 25             echo "delete $I finised."
									 26         else
									 27             echo "$I is not exists.so can not del"
									 28         fi
									 29     done
										elif [ $1 == '--help' ]; then 
											echo "Usage: bash file.sh --add arg0,arg1,arg2 | --del arg0,arg1,arg2 | --help arg0,arg1,arg2"
									 30 else										# 还可以添加--help 选项 elif [ $1 == '--help' ]
									 31     echo "$1 may not be --add or --del"
									 32     exit 10
									 33 fi
										
35  组合测试条件, 同时可以测试多个条件
		整数测试
		文件测试
		字符串测试
		-a : 与
		-o ：或
		!  : 非
		
		例如 ：
			if [ $# -gt 1 -a $# -le 3 ] ; then 
		或 
			if [ $# -gt 1 ] &&　[ $# -le 3 ] ; then
		
	练习 写脚本
	
		+=
		-=
		*=
		/+
		%=
		i++
		i--
		++i
		--I
		
			1.分别计算100以内的所有奇数和，偶数和，并分别显示之
				注 let SUM+=$I
				
  1 #!/bin/bash
  2 declare -i SUM=0
  3 
  4 for I in {1..100};do
  5     SUM=$[$SUM+$I]
  6 done
  7 
  8 echo $SUM			
		
36 	文件查找  locate  find 
		grep egrep fgrep 是文本查找，是文件中查找字符串的
		
	locate ： 非实时，非精确查找，根据全系统文件数据库进行的，唯一的优势是速度快
				locate passwd  
			  系统每天会对文件系统进行检索，加入数据库中，若今天新建的文件，查找时，可能查找不到。而且locate 是模糊查找。
			updatedb : 手动生成文件数据库
	find : 实时，精确，遍历指定目录中的所有文件完成查找，速度慢。
			优势是众多查找标准，支持文件权限，支持正则表达式查找
			
		find + 查找路径 + 查找标准 + 查找到以后的处理动作
				查找路径省略就默认代表当前目录
				查找标准省略就默认指定路径下的所有文件
				处理动作默认为显示到屏幕上
		查找标准：根据选项来确定
				-name  filename :根据文件名精确查找
					   文件名通配：
								*：任意长度任意字符
								?:
				-iname filename ：文件名匹配不区分大小写
				
				-regex pattern  :根据模式进行文件名查找
				
				-user username  :根据文件的属主来查找
								find /home  -user  sunyinhui
								
				-group groupname :根据文件属组来查找				
				
				-uid UID ：根据UID查找
				-gid GID ：根据GID查找
				-nouser  : 查找没有属主的文件  要经常将没有属主的用户，赋给管理员，免得其他用户乘虚而入
				-nogroup : 查找没有属组的文件
				
				-type + 以下参数： 根据类型来查找
							f : 普通文件
							d : 目录
							c ：字符
							b : 块设备
							l : 链接文件
							p : 管道设备
							s : 套接字设备
					
				-size + 参数  ：根据指定类型来查找  默认是字节
						  [+|-]nk 
						  [+|-]nM
						  [+|-]nG
						  +2k :大于2k
						  -2k :小于2k
						  2k  ：2k
						  find / -size +20M -ls  ： -ls 显示文件的详细信息
		组合条件： 没有指明时，默认是and 
			-a	:	and 
			-o	:	or
			-not:   not 
			
				find / -size +20M -a -type f 
				find / -not -type d  -a -not -user sunyinhui  或  find / -not \(-type d -o -user sunyinhui\)
				
			
		根据时间戳来查找文件
			-mtime + [+|-]天数 : 最后一次的修改时间
			-ctime 				: 最后一次的改变时间
			-atime 				: 最后一次的访问时间
		
			-mmin  [+|-]分钟数
			-cmin
			-amin 
						find ./ -amin +5
						find ./ -atime +10
		
		根据权限来查找
			-perm mode  :permission 
					mode : 755 744 775
					
			-perm -mode  :   每一位权限都必须精确匹配  文件权限能完全包含此mode时才能显示
							find ./ -perm 644
							644 rw-r--r--
							755 rwxr-xr-x 
							750 rwxr-x---
							文件权限是755的，也能显示出来.
									  750    不能显示出来
							find ./ -perm 001 
							find ./ -perm 022  
			-perm /mode  :   有一位匹配就显示
							find ./ -perm /644
			
	find 找到文件后的执行动作
		-print : 显示 默认动作
		-ls    : 类似ls -l的形式显示每一个文件的详细信息
		-ok  command {} \;   : 以反斜线分号结束    {} 的作用是存放find找到的文件，作为参数传给command    ：每一个操作都需要用户确认
		-exec command {} \;  : 同上   {}  只要引用找到的文件就使用{} 
		
						例如 ：找到其他用户具有写权限的文件，修改其写权限，使其失去写权限
								find ./ -perm -006 -exec chmod o-w {} \;  
							   找到属组属主都能执行权限的目录
							    find ./ -type d -ok chmod +x {} \;
								 
			注 -ok ：你的每一个操作都需要用户确认
						    找到属组有写权限的文件，并把文件命名为原来名字+.new  
							find ./ -perm -020 -exec mv {}  {}.new \;
							
							找到以.sh结尾的文件，并把其他用户拥有执行权限给去掉 
							find ./ -name "*.sh" -a -perm -111 -exex chmod o-x {} \;
		练习 
			1.	查找/var目录下属主为root 并且属组为mail的所有文件
					find /var -user root -a -group mail	
			2.	查找/usr目录下不属于root，bin student的文件
					find /usr -not -user root -a -not -user bin -a -user student 
			3.	查找/etc目录下最近一周内内容修改过且不属于root及student用户的文件
					find /etc -mtime -7 -a -not \(-user root -o -user student \) 
			4.	查找当前系统上没有属组或属主且最近一天没有被访问过的文件，并将其属主属组均修改为root 
					find  /  \(-nouser -o -nogroup\) -a -atime -1 -exec chmod root:root {} \;
			5.	查找/etc目录下大于1M的文件，并将其文件名写入/tmp/etc.largefiles文件中
					find /etc -size +1M -exec echo {} >> /tmp/etc/largefiles
			6.	查找/etc 目录下所有用户都没有写权限的文件，显示其详细信息
					find /etc -not -perm /222 -ls
		
	除了结合-ok -exec 之外，还可以跟 xargs 命令结合
			man xargs  : xargs - build and execute command lines from standard input
			
			find /etc -size +1M | xargs echo {} >> /tmp/etc.largefiles  
			xargs 本身可以不使用占位符{}
			find /etc -size +1M | xargs echo  >> /tmp/etc.largefiles  
			
37 	特殊权限   ：  http://www.cnblogs.com/fhefh/archive/2011/09/20/2182155.html
			SUID	: set user ID    运行某程序时，相应进程的属主是程序文件自身的属主，而不是启动者. 
									 注意不到万不得已，不要赋予SUID权限
					chmod u+s  file ：改变文件的SUID 
					chmod u-s  file   
						如果 file 本身具有执行权限，则SUID显示为s，否则显示为S;						
					ls -l /usr/bin/passwd 
							可以看出 本身就具有SUID权限，用户本身要修改自己的密码，并保存到文件中。所以要有执行权限，就必须要以管理员的身份运行
						
			SGID	：set group ID   运行某程序时，相应进程的属组是程序文件自身的属组，而不是启动者所属的基本组
					chmod g+s dir/file 
					chmod g-s dir/file  
					场景 ：公司内部开发小组，有很多用户，hadoop hbase ,hive.每个用户都可以在/project目录下都能创建文件，而且是hadoop创建的文件，
							hive可以读写，反之亦然。
							chmod g+s /tmp/project
					SGID 的作用是 在目录下创建的文件，不再是用户自己的基本组，而是这个目录的属组
						  hadoop 可以删除hbase创建的文件？？  可以 
						 可不可设置 别人创建的文件，其他用户没有权限删除

			Sticky	：在一个公共目录下，每一人都可以创建文件，删除自己的文件，但不能删除别人的文件
					chmod o+t dir  : 对目录而言
					chmod o-t dir  ：对目录而言
			
			这三个位组合起来，组成一个  按照SUID,SGID,Sticky
										000
										001
										010
										011
										100
										101
										110
										111
								
					chmod 1755 /path/to/file 
					      打头的数字表示特殊权限
			
					umask 表示为 0022  :第一位表示特殊权限
					

38	文件系统访问控制列表 FACL ：Filesystem Access Control List 
		tom 
		jerry
		
		Tom创建一个文件，希望Jerry也可以读写这个文件,只能修改other组具有rw-权限，但是除Jerry外还有其他用户有rw-权限，引入了安全问题
						  而且普通用户是没有chown权限的
							
	文件系统访问列表 FACL ：Filesystem Access Control List 	
						利用文件的隐藏或扩展属性，保存额外的访问控制权限，可以专门定义哪个用户，或者哪个组对此文件具有什么样的权限。
						也可以对目录设定额外的控制选项，此目录下的所有文件都默认继承目录上的控制访问列表.
			setfacl :设置facl ，可以设置到用户上， 也可以设定到组上
					-m 	  设定额外的控制选项
							u:UID:权限
							g:GID:权限		
					    setfacl -m u:hadoop:rw file 
						setfacl -m g:mygroup:rw file 
						
						对目录而言
						setfacl -m d:u:hadoop:rw dir 
						
					-x	  取消设定额外的控制选项
						setfacl -x u:hadoop file
						setfacl -x g:hadoop file
			ls -l  file 时，会发现 会多一个加号, 加号表示扩展属性。当使用复制等操作时，默认是会丢失的。
								-rw-rwxr--+ 1 root root ....
			
							Owner->Group->Other
有了facl 之后权限应用次序	Owner->facl(user)->Group->facl(group)->Other
				     
				
			getfacl :获得facl 	
					getfacl file 会列出以下信息
						#file:filename
						# owner:root
						# group:root
						user:rw-
						user:hadoop:rw-
						group::r--
						group:mygroup:rw-
						mask::rw-
						other::r--
			存疑	其中mask::rw- 的含义是设定额外的权限不能超过mask所设定的权限。若超出，会裁剪  
							
						
39  几个命令
			whoami	: print effective userid
			who		: show who is logged on 
			who -H  
			w       比who更详细：show who is logged on and what they are doing  
			last    ：用于显示/var/log/wtmp文件 显示登录历史及系统重启历史
					  -n : 只显示最近n次的登录信息。
			lastb   :用于显示/var/log/btmp文件，显示用户错误的登录尝试 
			lastlog : 显示每一个用户最近一次的成功登录信息
					-u username  指定特定用户
			basename /path/to/filename : 取得路径的基名，也就是获得filename
					basename $0  : 执行脚本时的脚本名称, 只获得脚本的基名
								
					  1 #!/bin/bash
					  2 echo "hello `basename $0` "
					输出 hello basename.sh
			mail    : 邮件	
					-s  :指定主题
						cat /etc/fstab | mail -s 'How are you ?'  root  : 给root用户发送/etc/fstab中的内容，主题设置为How are you 
					或  mail -s "How are you ?"  root  <  /etc/fstab   
			hostname : 主机名
			RANDOM  : 生成随机数
					 0-32768
					 随机数生成数 熵池
								  /dev/random
								  /dev/urandom
								
			        练习 生成10个随机数，取得最小值和最大值
							  1 #!/bin/bash
							  2 # 生成10个随机数
							  3 #当取得最小值时，要把第一次的随机数赋给MIN
							  4 declare -i MAX=0
							  5 declare -i MIN=0
							  6 for I in {1..10};do
							  7    R=`echo $RANDOM`
							  8    [ $I -eq 1 ] && MIN=$R
							  9    echo -n $R,
							 10     if [ $R -gt $MAX ];then
							 11         MAX=$R
							 12     fi
							 13     if [ $R -lt $MIN ]; then
							 14         MIN=$R
							 15     fi
							 16 done
							 17 echo ""
							 18 echo "the Max is $MAX"
							 19 echo "the Min is $MIN"
						   
			
		练习 写一个脚本
			每隔5秒钟，就来查看hadoop是否已经登录，如登录，显示其已经登录，并退出
			sleep 3 :睡眠3秒
			
40  case ：选择语句
			case SWITCH in 
					value1) 
						statement
						...
						;;		# 必须以双分号结尾
					value2)
						statement
						...
						;;
					value3)
						statement
						...
						;;
					*）
						statement
						...
						;;
			esac     #  以esac结束 
			
			其中 value 可取 a-z
							A-Z
							0-9
						    [a-zA-Z]
				
			只接受 start stop  restart status  之一
			  
	写一个脚本，可以接受选项及参数，而后能获取每一个选项， 及选项的参数，并能根据选项及参数做出待定的操作。比如：
				adminusers.sh --add tom,jerry  --del tom,blair -v|--verbose -h|help   
					其中 -v 显示详细信息	

								  1 #!/bin/bash
								  2 # 添加用户
								  3 # 当参数 为 -v 或 --verbose 时，才显示交互信息。否则不显示交互信息， 哲学 没有消息就是好消息
								  4 DEBUG=0
								  5 ADD=0
								  6 DEL=0
								  7 # 判定用户选定了哪些选项
								  8 for I in `seq 0 $#`; do
								  9     if [ $# -gt 0 ];then
								 10         case $1 in
								 11                  '-v'|'--verbose')
								 12                                 DEBUG=1
								 13                                 shift
								 14                                  ;;     
								 15                  '-h'|'--help')
								 16                         echo "Usage:`basename $0` --add user | --del user "
								 17                         exit 0;; # 只要有help选项，就退出
								 18                  '--add')
								 19                         ADD=1
								 20                         ADDUSER=$2
								 21                         shift 2;;
								 22                 '--del')
								 23                         DEL=1
								 24                         DELUSER=$2
								 25                         shift 2;;
								 26                 *)
								 27                         echo "Usage:`basename $0` --add user | --del user "
								 28                         exit 7
								 29          esac    
								 30                 
								 31     fi  
								 32 done    
								 33 # 根据选项执行相应的操作            
								 34 if [ $ADD -eq 1 ]; then 
								 35     for USER in `echo $ADDUSER | sed 's@,@ @g' ` ; do
								 36         if id $USER &> /dev/null ;then
								 37           [ $DEBUG -eq 1 ] && echo "$USER is exists." # 当debug为1时才显示，否则避免与用户交互
								 38         else
								 39             useradd $USER
								 40             echo "$USER" | passwd --stdin $I &> /dev/null
								 41             [ $DEBUG -eq 1 ] && echo "add $USER finised."
								 42         fi
								 43     done
								 44 fi
								 45 
								 46 if [ $DEL -eq 1 ]; then 
								 47     for USER in `echo $DELUSER | sed 's#,# #g'`; do
								 48         if id $USER &> /dev/null ;then
								 49             userdel $USER
								 50            [ $DEBUG -eq 1 ] && echo "delete $USER finised."
								 51         else 
								 52            [ $DEBUG -eq 1 ] &&  echo "$USER is not exists.so can not del."
								 53         fi
								 54     done
								 55 fi
				
	写一个脚本shodwlogged.sh ,其用法格式如下:
		showlogged.sh -v -c -h|--help
		其中，-h选项只能单独使用，用于显示帮助信息；
			  -c选项，显示当前系统上登录的所有用户数，如果同时使用了-v选项，则既同时显示登录的用户数，又显示登录用户的相关信息
						  1#!/bin/bash
						  2 declare -i shownum=0
						  3 declare -i showusers=0
						  4 
						  5 for I in `seq 1 $#` ; do
						  6     if [ $# -gt 0 ];then
						  7         case $1 in
						  8             '-h'|'--help')
						  9                 echo "Usage:`basename $0` -h|--help -c|--count -v|--verbose"
						 10                 exit 0;;
						 11             '-c'|'--count')
						 12                 let shownum=1
						 13                 shift;;
						 14             '-v'|'--verbose')
						 15                 let showusers=1
						 16                 shift;;
						 17             *)
						 18                 echo "Usage:`basename $0` -h|--help -c|--count -v|--verbose"
						 19                 exit 8
						 20         esac
						 21     fi
						 22 done
						 23 
						 24 if [ $shownum -eq 1 ];then
						 25     echo "Logged users:$shownum"
						 26 fi
						 27 
						 28 if [ $showusers -eq 1 ]; then
						 29     echo "they are:"
						 30     who 
						 31 fi		

41  磁盘管理
		MBR ：Master Boot Record  主引导记录 第0盘面第0磁道第0扇区 (512byte)
				有分为3段
						1.BoootLoader(446byte) : 引导加载器
						2.接着64byte中每16个字节标示一个分区，可供标示4个分区
						3.剩下2byte成为是魔数MagicNumber, 用来标记MBR是否是有效的 
		
		文件系统 ：metadata 元数据 
				 ：
		链接文件 ：777 
		
		硬链接 和 软链接
		
		
		硬链接：
			1.只能对文件建立硬链接，不能应用于目录
			2.不能跨文件系统
			3.创建硬链接会增加文件被链接的次数
		
		符号链接：
			1.可应用于目录
			2.可以跨文件系统
			3.不会增加被链接文件的被链接次数
			4.其大小为指定的路径所包含的字符个数
		
		
		ln [-s -v] SRC DEST 
			ln 不带参数 建立硬链接
			-s : 软链接
			-v :显示创建过程 
		
		du : 估计文件/目录大小 disk usage : estimate file space usage
			du + dir : 显示目录及其子目录的大小
			du -s dir ：只显示目录的大小
			du -h ：以人的角度查看文件大小，也就是换算成k , M , G
			
		df : 报告磁盘使用情况，默认是以多少块来显示
			-h 
			-i 显示有多少个inode
			
		

	设备文件 ：是没有大小的, 设备文件是设备的访问入口
		b :按块为单位，随机访问的设备
		c :按字符为单位，线性设备
			
		
		/dev :
				主设备号（major number）
					标示设备类型
				次设备号 (minor number)
					标示同一种类型中不同设备
			
			
		mknod :创建设备文件 make block or character special files
				 mknod [OPTION]... NAME TYPE [MAJOR MINOR]
						-m, --mode=MODE
							  set file permission bits to MODE, not a=rw - umask

						-Z, --context=CTX
							  set the SELinux security context of NAME to CTX						
				mknod  mydev c 66 0
				mknod  -m 640 mydev2 c 66 1 
		
		系统如何标示硬盘的？？？
		
		硬盘设备的设备文件名：
				IDE,ATA ： hd 开头
				SATA ：    sd 开头
				SCSI :     sd ...
				USB  ：    sd ...
						a,b,c ... 来区别同一种类型下的不同设备
			/dev/hda
			/dev/hdb
			....
		hda :
			hda1:第一个主分区         一个分区就是一个独立的文件系统
			hda2:第二个主分区
			hda3：第三个主分区
			hda4:第四个主分区
			hda5 :逻辑分区     逻辑分区只能从编号5开始
		
		查看当前系统识别了几块硬盘
			fdisk -l [/dev/sda1]  
		
		管理磁盘分区
			fdisk /dev/sda 
					p ： 显示当前硬件的分区，包括没保存的改动
					n :	创建新分区
						e:扩展分区
						p:主分区
					d : 删除一个分区
					w : 保存并退出
					q ：不保存退出
					t : 修改分区类型
					l ：显示所支持的所有类型
					
			创建分区之后，还要创建文件系统，才能被挂载和使用
			高级格式化就是创建文件系统的
			不要对已有数据的分区创建文件系统，重新创建文件系统会损坏原有系统
				创建文件系统
						mkfs : make file system  创建文件系统
							   文件系统类型：
											ext2 
											ext3
								只有内核中具有相应处理文件系统的模块，才能进行创建相应的文件系统
								
								cat /proc/filesystems ：可以查看 内核支持的文件系统类型
				mkfs :
					-t ：type 指定相应的文件系统类型, 加上分区即，不要对整个硬盘创建文件系统。
						mkfs -t ext2 /dev/sda5  :对/dev/sda5分区指定ext2类型的文件系统
			
			专门管理ext系列的文件系统：
				mke2fs ：不加 -j , 默认支持ext2
							-j : 支持日志功能的ext3
							-b ：指定块大小Block_Size，默认是4096，可用取值为1024、2048或4096
									mke2fs -b 2048 /dev/sda6
							-L :指定分区卷标，new-volume-label ，指定之后就可以通过卷标来引用这个分区
									mke2fs -L MyData /dev/sda7
									blkid 查看卷标
							-m +n ：指定为预留给超级用户的块数百分比 为n%
									mke2fs -m 3 /dev/sda8
							-i +n ：设定为多少个字节创建一个inode,默认为8192，给出的数值应该为块大小的2^n倍
									mke2fs -i 4096 /dev/sda9
							-N +n：设定inode的个数为n
							-F  : 强制创建文件系统
							-E  : 用户指定额外文件系统属性
				blkid :  用于查看磁盘或分区属性 UUID TYPE Label 卷标 
							root@slave1:~# blkid /dev/sda1
							/dev/sda1: UUID="2bdbe391-47ac-4de3-83d8-cbfc4a18052a" TYPE="ext2"
						               UUID : 全局统一标示符 由系统统一生成的
				e2label : 		
							e2label /dev/sda7 : 用于查看卷标
							e2label /dev/sda7 HelloMydata 设置新卷标为HelloMydata
				tune2fs :调整文件系统的相关属性 无损创建
						-j : 不损害原有数据情况下，将ext2升级为ext3文件系统， 注意不能降级
								tune2fs -j /dev/sda5 ,然后用blkid查看文件类型
						-L ：用于设定卷标
								tune2fs -L Mydata /dev/sda5
						-m ：调整预留百分比
						-r :指定预留块数
						-o :设定默认挂载选项，acl : Enable Posix Access Control Lists
						-c +n：设定多少次才自检,当取 0或-1时，不自检，关闭此功能
						-i +n: 每挂载多少天之后才进行自检，当取0或-1时，不自检，关闭此功能
						-l : 显示超级块中的信息 superblock 是有备份的
								tune2fs -l /dev/sda5
				dumpe2fs :显示文件系统相关信息
						  dumpe2fs /dev/sda5
								-h ：只显示超级块信息
						  
						  
									Group 0: (Blocks 1-8192)
									  Primary superblock at 1, Group descriptors at 2-2
									  Block bitmap at 3 (+2), Inode bitmap at 4 (+3)
									  Inode table at 5-506 (+4)
									  5625 free blocks, 3997 free inodes, 2 directories
									  Free blocks: 520-6144
									  Free inodes: 17, 21-4016
									Group 1: (Blocks 8193-16384)
									  Backup superblock at 8193, Group descriptors at 8194-8194
									  Block bitmap at 8195 (+2), Inode bitmap at 8196 (+3)
									  Inode table at 8197-8698 (+4)
									  2049 free blocks, 4016 free inodes, 0 directories
									  Free blocks: 14336-16384
									  Free inodes: 4017-8032								
							超级块在group 1 ，3,5,7,9,中有备份 
				显示空闲块，也就是碎片
					dumpe2fs /dev/mapper/ubuntu-root
				
				fsck  ：当文件系统出现错误，可以手动检查，并修复文件系统。check and repair a linux file system 
						-t ：type 指定文件系统类型
						-a : automaticlly repair the file system 自动修复文件系统。默认是询问，回复y
				
				e2fsck ：专门修复ext2，ext3，ext4文件系统的，  e2fsck - check a Linux ext2/ext3/ext4 file system
						-f :强制检测
						-p :自动修复
						
			挂载分区 ：挂载完成后，通过挂载点访问对应文件系统上的文件，系统重启后，挂载的分区将不存在
					将新的文件系统关联至当前根文件系统
					mount :挂载，不带参数时，显示当前系统中挂载设备及挂载点 ，显示的是/etc/mtab文件中的内容
						  mount [options] [-o options] Device Mount_Point
								-a ： 表示挂载/etc/fstab文件中定义的所有的文件系统
								-n :  默认情况下，mount 命令没挂载一个设备，都会把挂载的设备信息保存至/etc/mtab文件
									  使用-n选项，意味着挂载设备时，不把信息写入此文件，静默了
								-t FSType: 指定正在挂载设备上的文件系统的类型，不给出此选项， mount会调用blkid命令获取对应文件系统类型
								-r : 只读挂载，挂载系统为只读，挂载光盘时，才使用此选项  ： mount -r /dev/cdrom /media/
								-w : 读写挂载，挂载系统为读写，默认是读写挂载，当挂载为光盘时，有写保护的，只能是只读挂载
												root@slave1:/# mount /dev/cdrom /media/
												mount: block device /dev/sr0 is write-protected, mounting read-only
								-o : 指定额外的挂载选项，也既指定文件系统启用的属性。
										如 	async 异步写入
											atime 时间戳 更新，每访问一次，就更新时间戳，对于访问量很大的情况而言，是没有意义的
													每更新一个时间戳，就会产生一次IO, 会影响系统性能 ，可以关闭，noatime 
											auto :是否支持-a 选项能自动挂载
											default : 使用默认。rw,suid,dev,exec,auto,nouser,and async
											dev  ： 如果设备有设备文件，是否可以启用他们
											exec :  允许文件上的执行文件有执行权限，挂载u盘时，可以设置noexec，不让执行文件具有执行权限。防止病毒感染
													这样u盘是只读的，而且没有执行权限
											owner: 	允许普通用户挂载这个文件系统的
											remount : 重新挂载当前文件系统 
														mount -o remount /dev/cdrom /media
											ro    : 挂载为只读
														mount -o ro /dev/cdrom /media
											rw    : 读写挂载
											sync  : 同步写入
											suid  : 启用suid功能， 启用特殊权限，这是一种不安全的做法
									注意使用多个选项时，用逗号隔开
														mount -o remount,ro /dev/cdrom [/media]
														其中 挂载点可以省略,因为是重新挂载到原来的位置
														
									
						mount 设备 挂载点  ： 挂载点就是目录
							mount /dev/sda5 /mnt/test/
							设备可选 ：
								设备文件, /dev/sda5
								卷标， LABEL=" "
								UUID, UUID=" "
							挂载点，其实就是某个目录，对这个目录的要求是
									1. 此目录没有被其他进程使用
									2. 目录得事先存在
									3. 目录中原有的文件将会被暂时隐藏
					挂载完成后，要通过挂载点访问对应文件系统上的文件；
																	
			卸载分区：
					将某文件系统与当前根文件系统的关联关系移除
					umount : 卸载文件系统
						umount 设备
					或 
						umount 挂载点
					卸载注意事项：
							 挂载的设备没有被进程使用
							
								
						
						
				
				
			
			查看分区表
				cat /proc/partitions 
			让内核重读分区表
				·partprobe
					
			
 		Linux分为高级格式化和低级格式化
		
				1. 低级格式化是格式化磁道
				2. 高级格式化是创建文件系统的  mkfs -t ext3  创建ext3类型的文件系统
			
		文件操作：
				open
				read
				write
				close
				create 
				delete
		
		FAT32
		NTFS
		ISO9660
		CIFS
		
		
		
		ext2
		ext3
		ext4
		xfs
		reiserfs
		
		
		nfs
		ocfs2
		gfs2
		
		
		用户模式 用户空间
		内核模式 内核空间 内核提供VFS，才能支持多种文件系统
					VFS
						Virtual File System 
							虚拟文件系统
					inode : index node 	：inode号，权限，属组属主，时间戳，文件大小。等信息
			bitmap : 位图 	   
			superblock 超级块
			block bitmap :块位图
			inode bitmap ：inode位图
			inode Table :inode 表
			GDT ： Group Distraction Table 块组描述组表
			
			
			ext3 ext2 
				ext3 ： 支持日志的功能，journal file system 日志文件系统
							先把文件inode存放在日志区，没有错误，就把文件存放在文件的数据区，如无损坏就把inode信息写入到
							可以查看日志文件系统，查看损坏的文件。
							缺点是，需要多一次的读写操作。

				ext2 :	
			
			fdisk :
			
				
			
		练习 ：
			1. 
			2.
			3.
			4. 调整其预留的百分比为3%
					tune2fs -m 3 -L DATA　／dev/sda7
			5. 以重新挂载的方式，挂载此文件系统为不更新时间戳，并验证其效果
				stat /backup/initab
				cat /backup/initab
				stat 
				
				mount -o remount,notime /backup 
				cat 
				stat 
			6. 对文件系统强行进行一次检测
					e2fsck -f /dev/sda7
			7. 删除复制而来的所有文件，并将此文件系统重新挂载为同步sync,而后复制/etc目录中的所有文件至此挂载点，体验其性能变化
				rm -rf /dev/sda7
				mount -o remount ,sync  /backup
				cp -r /etc/* /backup 
42 swap分区

		虚拟内存 
		sharetime
			
			cpu: time slice
			memory：虚拟内存
			I/O：多路复用
		
		x86：支持虚拟地址寻址，线性地址
		
		fdisk命令中，调整分区类型为82
		
		创建文件交换分区: 
			mkswap  /dev/sda8 将其格式化
			
		挂载分区：
			swapon /dev/sda8
				-a : 启用所有的定义在/etc/fstab文件中的交换设备
		卸载分区：
			swapoff /dev/sda8
		
		文件系统的配置文件/etc/fstab 文件系统表
			所有写在/etc/fstab文件中的每个设备，系统在开机时会自动挂载
		cat /etc/fstab
			需要挂载的设备		挂载点	  文件系统类型		挂载选项		转储频率 		文件系统检测次序(只有根可以为1)
			/dev/sda9			/mnt/test    ext3			 defaults 			0                0 
				
			
		回环设备： 将文件模拟成设备，进行挂载
			loopback 使用软件来模拟实现硬件
			这种设备时一种伪设备，使得文件可以如同块设备一般被访问。
			在使用之前，循环设备必须与现存文件系统上的文件相关联。
			这种关联将提供给用户一个应用程序接口，接口将允许文件视为特殊文件使用
			因此，如果文件中包含一个完整的文件系统，那么这个文件就能如同磁盘设备一样被挂载
		
		
		
		dd 命令：转换并复制文件
			dd if=/etc/inittab of=/root/inittab
				使用if指定数据来源inputfile ，of指定outputfile
			dd与cp 不同的是 cp以文件为单位复制，而dd是以低层的数据流为单位
				cp是从文件系统读取到内存，然后再把内存中的数据写入到文件系统中另外的区域
				dd是从低层01数据，直接复制到文件系统的别处。
			
			dd 可以指定只复制文件的某部分
				bs= 指定复制的blocksize字节是多大 bs=1024 以1024字节为单位
				count= 复制多少个bs 
				
			dd的强大之处
				dd if=/dev/sda of=/mnt/usb/mbr.backup bs=512 count=1   
					硬盘的开头处512字节就是mbr
					实现备份mbr
				dd if/mnt/usr/mbr.backup of=/dev/sda bs=512 count=1
					覆盖被损坏的mbr
				dd 命令可以做系统镜像
					
		dd if=/dev/zero of=/dev/null bs=1M count=1024 
			/dev/zero  输出指定大小的0, 
			/dev/null  接收无限任意的数据
			以子之矛，攻子之盾
			
		dd if=/dev/zero of=/var/swapfile bs=1M count=1024
				1024+0 records in
				1024+0 records out
				1073741824 bytes (1.1 GB) copied, 38.8813 s, 27.6 MB/s
			可以实现磁盘测试
		mkswap  : 将文件创建成swap类型
		mkswap /var/swapfile  :创建分区文件
		swapon /var/swapfile  :启动分区文件
		
			
		mount 可以挂载iso镜像 加参数 -o loop 作为本地回环设备
			 mount -o loop /root/rhci-5.8-1.iso /media 
			 
		
		fuser -v /mnt/test
		fuser  : 显示哪些进程正在使用文件或套接字
			-v : 查看某文件
			-k : 杀死正在访问文件的进程
			-m ：name 指定一个不同的命名空间，支持不同的空间文件，列出访问这个文件或文件系统的所有进程
			-km :经常一起使用
		fuser -km /mnt/test  ： 终止正在访问挂载点的所有进程
		
		
		练习 ：
			1. 创建一个5G分区, 文件系统为ext3，卷标为Mydata,块大小为1024，预留管理空间为磁盘分区的3%，要求开机后可以自动挂载至/data目录
					并且挂载的设备要使用卷标进行引用
			
			2. 创建一个本地回环文件/var/swaptemp/swapfile 用于swap ,要求大小为512M,卷标为SWAP-FILE,且开机自动启动此交换设备
				mkdir /var/swaptemp/swapfile 
				dd if=/dev/zero of=/var/swaptemp/swapfile bs=1M count=512
				mkswap LABLE=SWAP-FILE  /var/swaptemp/swapfile 
				
				打开 vim /etc/fstab 添加一行
				/var/swaptemp/swapfile   swap swap defaults 0 0 
			
			3. 上题，如何让其自动挂载的同时启动ACL 功能
				vim /etc/fstab 
				LABEL='Mydata'  /data  ext3  defaults,acl 0 0 
				
				
43. 压缩、解压、归档
		压缩格式有 gz bz2 xz zip Z 
		
		
		gzip:  .gz  
			使用 gzip filename : 会删除原文件，得到 filename.gz 而压缩目录会对目录下的所有文件进行压缩
			gzip -d filename.gz  也能解压缩文件
				 -d ： --decompress 
			gzip -n : 指定压缩比，默认是6
		gunzip: 解压缩
			gunzip filename.gz ：解压完后也会删除原文件
		zcat ：在不解压文件的情况下，查看压缩后的文件。
			  cat 查看会乱码
			  zcat filename.gz 
			
		bzip2: .bz2 比gzip有着更大压缩比的工具,使用格式类似, 只能压缩文件，不能压缩目录，压缩也会删除原文件
			bzip2 /path/to/file   ： 压缩
			bzip2 -d /path/to/file.bz2 : 解压缩 会删除原文件
				  -k : keep 会保留原文件 
			bunzip2 /path/to/file.bz2 ： 解压缩
			bzcat /path/to/file : 不解压查看
		
		
		xz: .xz   用法与bzip2 相同
			xz /path/to/file   ： 压缩
			xz -d /path/to/file.bz2 : 解压缩 会删除原文件
				  -k : 会保留原文件
			unxz /path/to/file.bz2 ： 解压缩
			xzcat /path/to/file : 不解压查看
		
		zip : 压缩后默认不删除原文件 package and compress (archive) files 可以压缩目录  
			zip + 压缩后的文件名.zip  + 压缩的文件或目录...
			zip filename.zip file1 file2 ...
			unzip filename.zip 
		tar : 实现归档，但不压缩 .tar
			-c ：创建归档文件
			-f file.tar : 将文件夹归档为file.tar 文件
				tar -cf test.tar test*.txt
				把test开头的txt文件归档为test.tar
			-x : 还原归档
				tar -xf test.tar
			--xattrs : 	归档时，保留文件的扩展属性信息
						在备份是很重要
			-t : 不打开归档文件，就能查看里面的文件.
				tar -tf test.tar
			-z ： 调用压缩gzip和解压缩命令gunzip
			-zcf ：归档并调用gzip压缩
			-zxf ：调用gunzip解压缩并展开归档
			
			-j :调用压缩bzip2和解压缩
			-jcf : 归档并调用bzip2
					tar -jcf test.tar.bz2 test*.txt
			-jxf : 调用bunzip解压缩并展开归档
					tar -jxf test.tar.bz2
			
			-J :调用压缩xz和解压缩
			-Jcf ： 归档并调用xz压缩
					tar -Jcf test.tar.xz  test*.txt
			-Jxf :  调用unxz解压缩并展开归档
			-Jtf : 不解压，直接看里面的内容
	
	cpio : 归档工具
		
		
		练习 ： 写一个脚本
		从键盘让用户输入几个文件，脚本能够将此几个文件归档压缩成一个文件  脚本与用户交互 read 
					
			  1 #!/bin/bash
			  2 #
			  3 
			  4 echo -n  "Input two Integers:"
			  5 
			  6 read A B
			  7 echo "$A plus $B is: $[ $A + $B ] "
		read :
			-p : 提示信息 prompt
				  1 #!/bin/bash
				  2 #
				  3 read -p "Three files :" FILE1 FILE2 FILE3
				  4 read -p "Destination :" DEST
				  5 
				  6 tar -jcf ${DEST}.tar.bz2 $FILE1 $FILE2 $FILE3


		  1 #!/bin/bash
		  2 # 
		  3 read -p "Three files: " file1 file2 file3
		  4 read -p "Destination :" dest
		  5 read -p "Compress[gzip|bzip2|xz] :" comp
		  6 
		  7 case $comp in
		  8     gzip)
		  9         tar -zcf ${dest}.tar.gz $file1 $file2 $file3;;
		 10     bzip2)
		 11         tar -jcf ${dest}.tar.bz2 $file1 $file2 $file3;;
		 12     xz)
		 13         tar -cf ${dest}.tar  $file1 $file2 $file3
		 14         xz ${dest}.tar;;
		 15     *)
		 16         echo "Unkown compress"
		 17         exit 9
		 18         ;;
		 19 esac
				  
44 while 循环  使用于循环次数未知的情况
		
		while CONDITION ; do
			statement
			....
		done
		
		练习 计算 100以内正整数的和
			  1 #!/bin/bash
			  2 #
			  3 declare -i I=1
			  4 declare -i SUM=0
			  5 
			  6 while [ $I -le 100 ]; do
			  7    let  SUM+=$I
			  8    let  I++
			  9 done
			 10 
			 11 
			 12 echo $SUM

45 磁盘管理
		
		写一个脚本， 显示一个菜单给用户，
					d|D) show disk usage.
					m|M) show memory usage.
					s|S) show swap usage
					*) quit
		当用户选定给定选项后显示相应的内容。
		当用户选择完成，显示相应信息后，不退出，而让用户从新选择，除非用户输入quit则退出。
						#!/bin/bash
						# 
						cat << EOF
						d|D) show disk usage.
						m|M) show memory usage.
						s|S) show swap usage
						*) quit
						EOF

						read -p "Your choice:" CHOICE
						while [ $CHOICE != 'quit'  ];do
								case $CHOICE in
								d|D)
										echo "Disk usage:"
										df -h ;;
								m|M)
										echo "Memory usage:"
										free -m | grep "Mem";;
								s|S)
										echo "Swap usage:"
										free -m | grep "Swap";;
								*)
										echo "Unknow";;
								esac

						read -p "Again your choice:" CHOICE
						done
				扩展  显示有用信息时加上颜色
				
		
		安装RHEL6.3 x86_64的方法，前提确保你的cpu支持硬件虚拟化技术
			1、创建虚拟机
			2、下载isos目录中的rhci-rhel-6.3.1-1.iso，并导入虚拟机的虚拟光驱
			3、在boot提示符输入：linux ip=172.16.x.1 network=255.255.0.0 gateway=172.16.0.1 dns=172.16.0.1 ks=http://172.16.0.1/rhel16.cfg
			
		watch: 周期性的执行指定命令，并以全屏方式显示结果
				-n # ：指定周期长度，单位为秒，默认为2s
			watch -n # 'command'  	
			  
		madam : 用户空间工具，管理工具
		
		md  multi device
				/dev/md0
				/dev/md#
		dm  ：Device Mapper
				逻辑设备
					更为强大，提供RAID(磁盘阵列) 、LVM2(逻辑卷)
				
			
		一、扩展逻辑卷
			lvextend  先扩展物理边界
			resize2fs 再扩展逻辑边界
		
		二、缩减逻辑卷
			
			确保缩减后的空间大小依然能够存储原有所有数据
			不能在线缩减，得先缩减
			在缩减之前强行检查文件系统，确保文件处于一致性状态
			df -h 
			umount 
			e2fsck -f 
			
			先缩减逻辑边界
			然后再缩减物理边界
			resize2fs 
			lvreduce
		
		三、快照卷
			
			1 生命周期为整个数据时长，在这段时长内，数据的增长量不能超出快照卷大小
			2 快照卷应该是只读的
			3 跟原卷在同一卷组内
			
			
			lvcreate 
					-s :指定快照卷
					-p r|w  ：指定为只读和写
					-L ：大小
					-n : 指定快照卷名称
			
			lvcreate -L # -n SLV_NAME -s -p r /path/to/LV

46 until 脚本编程控制结构
		
		顺序
		选择
			if 
			case
			
		循环
			for
				for c语言风格

					for ((exp1; exp2; exp3)) ; do
						statement
					done
					
					
				eg:
					  1 #!/bin/bash
					  2 declare -i SUM=0
					  3 for I in {1..100};do
					  4     SUM+=$I
					  5 done
					  6 echo "SUM=$SUM "
					  7 echo "I=$I"
					  8 declare -i SUM2=0
					  9 for ((J=0;J<=100;J++));do
					 10     SUM2+=$J
					 11 done
					 12 echo "SUM2=$SUM2"

					
					
			
			while
			until 
		
		条件不满足，进入循环，直到条件满足退出循环
		until command;	do
			statement
			...
		done
		
		
				#!/bin/bash
				#
				read -p "Input Something:" STRING
				until [ $STRING == 'quit' ];do
						echo $STRING | tr 'a-z' 'A-Z'
						read -p "Again Input Something:" STRING
				done
						
		练习 写一个脚本
				1. 通过ping命令测试192.168.0.151到192.168.0.254之间的所有主机是否在线
				如果在线，就显示“ip is up.” 其中ip要转换为真正的主机地址，且以绿色显示
				如果不在线，就显示“ip is down” ,同上，但要以红色显示
 			要求分别使用while for until 实现.
			
			ping -c 1 192.168.1.7
			echo $?
			
			man ping  
				-c :次数 stop aster sending count ECHO_REQUEST 
				-W :超时退出
				
			ping  -c 1 -W 192.168.1.7 &> /dev/null
			echo $?
			
			fdisk -l 2> /dev/null | grep "^Disk /dev/[sh]d[a-z]" | awk -F: '{print $1}'

		

		练习 写一个脚本 ： 为虚拟机新增一块硬盘，假设它为/dev/sdb 为指定的硬盘创建分区
			1. 列出当前系统上所有的磁盘，让用户选择，如果选择quit 则退出，如果用户选择错误，就让用户重新选择
			2. 当用户选择后，提醒用户确认接下来得到操作可能会损坏数据，并请用户确认，如果用户选择y就继续，否则，让用户重新选择
			3. 抹除那块磁盘上的所有分区，提示 抹除所有分区后执行sync命令，并让脚本睡眠3秒后再分区 。并为其创建三个主分区，大小分别为20M、512M、128M 
			   且第三个分区为swap分区类型。 提示 将分区命令通过echo传送给fdisk即可实现。
			 
			 fdisk -l 2> /dev/null  | grep "^Disk /dev/[sh]d[a-z]" | awk -F: '{print $1}'
			 
					  1 #!/bin/bash
					  2 # 
					  3 echo "Initial a disk..."
					  4 echo -e "\033[31mWarning!\033[0m"
					  5 fdisk -l 2> /dev/null | grep -o "^Disk /dev/[sh]d[a-z]"
					  6 
					  7 read -p "Your choice:" PARTDISK
					  8 if [ $PARTDISK == 'quit'  ]
					  9 then
					 10     echo "quiting"
					 11     exit 7
					 12 fi
					 13 
					 14 until fdisk -l 2> /dev/null | grep -o "^Disk /dev/[sh]d[a-z]" | grep "Disk $PATRDISK$" 
					 15 do
					 16     read -p "Wrong option, Again choice Your choice:" PARTDISK
					 17 done
					 18 
					 19 read -p "Will destroy all data, continue:" CHOICE
					 20 until [ $CHOICE =='y' -o $CHOICE =='n' ]
					 21 do
					 22         read -p "Will destroy all data, continue:" CHOICE
					 23 done
					 24 
					 25 if [ $CHOICE =='n' ];then
					 26     echo "Quit"
					 27     exit 9
					 28 else
					 29     dd if=/dev/zero of=$PARTDISK bs=512 count=1 &> /dev/null
					 30     sync
					 31     sleep 3
					 32     echo 'n
					 33     p
					 34     1
					 35 
					 36     +20M
					 37     n
					 38     p
					 39     2
					 40 
					 41     +512M
					 42     n
					 43     p
					 44     3
					 45 
					 46     +128M
					 47     t
					 48     3
					 49     82
					 50     w' | fdisk $PARTDISK &>/dev/null
					 51     partprobe $PARTDISK
					 52     sync
					 53     sleep 2
					 54     mke2fs -j ${PARTDISK}1 &>/dev/null
					 55     mke2fs -j ${PARTDISK}2 &>/dev/null
					 56     mkswap -j ${PARTDISK}3 &>/dev/null
					 57 fi
			
		修改系统的vimrc  cat /home/mint/.vimrc >> /etc/vim/vimrc
		
47  编译
		
		程序组成部分：
					二进制程序
					库
					配置文件
					帮助文件
				/boot
				/etc
				/usr
				/var
				/dev
				/lib
				/tmp
				/bin
				/sbin
				/proc
				/sys
				/mnt
				/media
				/home
				/root
				/misc
				/opt
				/srv
		
		/etc /bin /sbin /lib 
				系统启动就需要用到的程序，这些目录不能挂载额外的分区，必须在根文件系统的分区上
		
		/usr/
			bin
			sbin
			lib 
				操作系统的核心功能，可以单独分区
		
		/usr/local/
				bin
				sbin
				lib
				etc
				man 
				第三方软件
		/opt

48  break continue 
			
			break :提前退出循环
			continue ：结束本次循环，进入下一次循环
		
		死循环 
		while : ; do
			
		done
		
		break 跳出循环
		while : ; do
			break
		done
		
		while的特殊用法二
		
		while read LINE; do
		done < /path/to/somefile
			
		写一个脚本 
			1 判断一个指定的bash脚本是否有语法错误 如果有语法错误 则提醒用户键入Q或者q无视错误并退出，其他任何键可以通过vim 打开这个指定的脚本
			2 如果用户通过vim打开编辑后保存退出时仍然有错误，则重复第1步中的内容，否则，就正常退出
		./syntax.sh a.sh
		
		bash -n $1 

			  1 #!/bin/bash
			  2 # 
			  3 
			  4 until bash -n $1 &> /dev/null ; do
			  5     read -p "Syntax error, [Qq] to quit, others for editing:" CHOICE
			  6     case $CHOICE in
			  7         q|Q)
			  8             echo "Something wrong,quiting."
			  9             exit 5
			 10             ;;
			 11         *)
			 12             vim + $1
			 13             ;;
			 14     esac
			 15 done
		
49 function 函数 功能 
			结构化编程 
			代码重用
			不能独立运行，需要调用时执行，可以被多次调用
			
			定义一个函数：
			function FUNCTION{
				command
			}
			
			FUNCTION(){
				command
			}
			
			自定义执行状态返回值；
				return # 
			接收参数的函数：位置参数
			
		练习 写一个脚本	判定192.168.0.200-192.168.0.254之间的主机哪些在线，要求
				1 使用函数来实现一台主机的判定过程
				2 在主程序中调用此函数判定指定范围内的所有主机的在线情况
			
						  1 #!/bin/bash
						  2 #
						  3 
						  4 PING() {
						  5     if ping -c -W $1 &> /dev/null ;then
						  6         echo "$1 is up."
						  7     else
						  8         echo "$1 is down."
						  9     fi
						 10 }
						 11 for I in {0..25};do
						 12     PING 192.168.1.$I
						 13 done

		
		
					  1 #!/bin/bash
					  2 #
					  3 
					  4 PING() {
					  5     if ping -c -W $1 &> /dev/null ;then
					  6         return 0
					  7     else
					  8         return 1
					  9     fi
					 10 }
					 11 for I in {0..25};do
					 12     PING 192.168.1.$I
					 13     if [ $? -eq 0 ];then
					 14         echo "192.168.1.$I is up "
					 15     else
					 16         echo "192.168.1.$I is down "
					 17     fi
					 18 done

		
		写一个脚本、使用函数完成
				1、函数能够接受一个参数，参数为用户名
					判断一个用户是否存在
					如果存在、就返回此用户的shell和UID、并返回正常状态值
					如果不存在、就说此用户不存在，并返回错误状态值
				2、在主程序中调用函数
			扩展1、在主程序中、让用户自己输入用户名、传递给函数来进行判断
			扩展2、在主程序中、输入用户名判断后不退出脚本、而是提示用户继续输入下一个用户名；如果用户不存在，提示重新输入 但如果用户输入的是q或Q就退出

				  1 #!/bin/bash
				  2 # 
				  3 user() {
				  4 
				  5     if id $1 &> /dev/null;then
				  6         echo "`grep ^$1 /etc/passwd | cut -d: -f3,7`"
				  7         return 0
				  8     else
				  9         echo "no $1"
				 10         return 1
				 11     fi
				 12 }
				 13 
				 14 read -p "Please input username:" username
				 15 until [ $username == 'q' -o $username == 'Q' ] ; do
				 16     user $username
				 17     if [ $? == 0 ];then
				 18         read -p "Please input username again:" username
				 19     else
				 20         read -p "no $username ,please input again:" username
				 21     fi
				 22 done

			函数也可以接受参数、既可以向函数传递参数
		
50 进程		
		ps : prosess status  程序状态
			-a : 显示所有与终端有关的进程， 在终端中打开的进程
			-u ：显示是哪个用户启动的进程
			-x ：显示所有与终端无关的进程，在系统启动时就打开的进程
			
			
		TTY ? 表示与终端无关
		
		
		进程状态：
			D: 表示 不可终端的睡眠
			R: 表示 运行或就绪
			S: 表示可中断的睡眠
			T: 表示停止
			Z: 表示僵尸态 
			
			<: 表示高优先级的进程
			N：表示低优先级的进程
			+：表示前台进程组中的进程
			l: 表示多线程进程
			s: 表示会话进程的首进程 如 mdm , 关闭mdm 就必须关闭其所有的子进程
							
					 ├─mdm───mdm─┬─Xorg
					 │           └─cinnamon-sessio─┬─applet.py───{applet.py}
					 │                             ├─cinnamon-killer───2*[{cinnamon-killer}]
					 │                             ├─cinnamon-launch─┬─cinnamon───5*[{cinnamon}]
					 │                             │                 └─{cinnamon-launch}
					 │                             ├─cinnamon-screen───3*[{cinnamon-screen}]
					 │                             ├─cinnamon-settin───4*[{cinnamon-settin}]
					 │                             ├─mintupdate-laun───sh───mintUpdate───2*[{mintUpdate}]
					 │                             ├─nemo───3*[{nemo}]
					 │                             ├─nm-applet───2*[{nm-applet}]
					 │                             ├─polkit-gnome-au───{polkit-gnome-au}
					 │                             ├─ssh-agent
					 │                             └─3*[{cinnamon-sessio}]

					
				mint@Virtual-Machine ~/LinuxCluster $ ps -aux
				USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
				root         1  0.0  0.3   4476  3704 ?        Ss   09:01   0:02 /sbin/init   ： 回话进程的首进程
				root         2  0.0  0.0      0     0 ?        S    09:01   0:00 [kthreadd]
				root         3  0.0  0.0      0     0 ?        S    09:01   0:03 [ksoftirqd/0]  加中括号的进程是内核进程
				root         5  0.0  0.0      0     0 ?        S<   09:01   0:00 [kworker/0:0H]
				root         7  0.0  0.0      0     0 ?        S    09:01   0:07 [rcu_sched]
				root         8  0.0  0.0      0     0 ?        S    09:01   0:00 [rcu_bh]
				root         9  0.0  0.0      0     0 ?        S    09:01   0:00 [migration/0]
				root        10  0.0  0.0      0     0 ?        S    09:01   0:05 [watchdog/0]
				root        11  0.0  0.0      0     0 ?        S<   09:01   0:00 [khelper]
				root        12  0.0  0.0      0     0 ?        S    09:01   0:00 [kdevtmpfs]
				root        13  0.0  0.0      0     0 ?        S<   09:01   0:00 [netns]
				root        14  0.0  0.0      0     0 ?        S<   09:01   0:00 [perf]
				root        15  0.0  0.0      0     0 ?        S    09:01   0:00 [khungtaskd]
				root        16  0.0  0.0      0     0 ?        S<   09:01   0:00 [writeback]
				root        17  0.0  0.0      0     0 ?        SN   09:01   0:00 [ksmd]
				root        18  0.0  0.0      0     0 ?        SN   09:01   0:00 [khugepaged]
				root        19  0.0  0.0      0     0 ?        S<   09:01   0:00 [crypto]
				root        20  0.0  0.0      0     0 ?        S<   09:01   0:00 [kintegrityd]			
		
					-elF :
						-e 显示所有进程,环境变量
					　　-f 全格式	
					　　-h 不显示标题
			　　		-l 长格式
					ps -aux | grep "bash" 
							查找进程中与bash相关的进程
					ps -elF | grep "bash"
		
		pstree : 显示进程树
		
		pgrep : 以grep风格显示搜索的进程  只显示进程号
				pgrep bash   
				pgrep -u root bash : 表示以root为属主运行的bash进程	
		
		
		pidof : 根据进程名查找进程号
				pidof init 
		
		top : 监控
		top -d 1  刷新时长
			-b : 多批显示
			-n # :显示指定#屏
		在执行top界面下，敲入以下字符 	
					M : 根据驻留内存大小进行排序
					P : 根据CPU使用百分比进行排序
					T ：根据累计时间进行排序
					
					l : 是否显示平均负载和启动时间
					t : 是否显示进行和CPU状态相关信息
					m : 是否显示内存相关信息
					
					c : 是否显示完整的命令行信息
					q : 退出top
					k : 终止某个进程
			
			
		进程间通信：
				共享内存
				信号
				semaphore
				
		kill 
			mint@Virtual-Machine ~ $ kill -l
			 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
			 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
			11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
			16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
			21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
			26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
			31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
			38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
			43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
			48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
			53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
			58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
			63) SIGRTMAX-1	64) SIGRTMAX	
		重要的信号 
			1 表示sigup    :可以让一个进程不用重启，就可以重读配置文件，并让新的配置信息生效
			2 表示sigint   ：interrupt 中断 Ctrl + C 
			9 表示sigkill  : 杀死一个进程
			15 表示sigterm ：终止一个进程, 默认信号
			
		指定一个信号
			信号号码 kill -15
			信号名称 kill -SIGKILL
			信号名称简写 kill -UP
		
		杀死一个进程
			ps -aux | grep "top"
			得到进程号 pid 
			kill pid 		
		
		killall command  : 加强版 
		
		调整nice值
			如果进程已经启动 renice NI PID 
			在启动时指定nice值 nice -n NI command 
				nice -n -3 useradd hbase
		
		前台和后台 
			前台 占据着命令行终端的是前台
			后台 启动之后就释放命令提示符，后续的操作在后台执行
		
		前台->后台 ： 
					Ctrl + z 
					命令行后加上 &  ：让命令在后台执行
					
		
		bg : 让后台的停止作业继续运行。 查看作业号：jobs 
			bg [[%]jobid] : jobid可省 ，默认是+号的作业
			
  		fg : 将后台的作业调回前台，用法同bg 
			 fg [[%]jobid]
		jobs : 查看后台的所有作业号
			作业号，不同于进程号
				+ ： 命令将默认操作的作业
				- ： 命令将将第二个默认操作的作业
		kill %jobid ：也可以终止作业， 注意要带百分号
		
			
		vmstat : 系统状态命令 
				mint@Virtual-Machine ~/LinuxCluster $ vmstat
				procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
				 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
				 0  0      0 129692  62020 500192    0    0    19    12   68  401 14  4 82  0  0

			r：运行队列长度
			b: 阻塞队列长度
			
		vmstat n ： 每隔n秒显示一次
		vmstat n m : 每隔n秒显示一次,只显示m次
		
		cat /proc/meminfo
51 chroot 
   ldd  ： 显示共享库依赖
        ldd /bin/bash
		
	
	运行级别:0-6
			0：halt
			1: single user mode 直接以管理员身份切入
			2：multi user mode , no NFS
			3：multi user mode, text mode 命令行模式
			4: reserved
			5: mulit user mode, graphic mode 
			6: reboot
	查看运行级别
			runlevel 
			who -r 
			
	查看内核release号
			uname -r 
		
52 修复、安装grub
			
		第一种方式：
					# grub
					grub> root (hd0,0)
					grub> set (hd0)
					grub> reboot 
		第二种方式：
					# grub-install --root-directory=/path/to/boot's parent dir  /path/to/device
					
		修复grub 
			grub> root (hd0,0)  # 注意支持find命令 find (hd0,0)/ 可以查看vmlinuz...是否存在
			grub> kernel /vmlinuz...  # 支持tab补全 指明kernel
			grub> initrd /initrd-...   # initrd (ramdisk)
			grub> boot 
			
 		kernel初始化的过程
			1、设备探测
			2、驱动初始化 从initrd模块中装载驱动模块
			3、以只读挂载根文件系统
			4、装载第一个进程init(PID:1)
			
			
		/sbin/init:( /etc/inittab)
			
	内核模块管理
			lsmod : 查看
			modprob mod_name : 装载某模块
			modprobe -r mod_name : 卸载某模块
			
			modinfo mod_name : 查看模块的具体信息
			
			insmod /path/to/module_name : 装载模块
			rmmod /path/to/module_name :卸载模块
			
			depmod /path/to/module_dir 
				
	系统裁剪		
		/etc/issue 文件的内容
	
	
	    rc.sysinit: 挂载/etc/fstab中定义的其他文件系统
		
			
			
		查看本机硬件设备信息
				1、cat /proc/cupinfo
				2、lsusb 
				3、lspci
				4、hal-device 
						Hardware Abstract Layer 硬件抽象层
			
		编译内核
			1 配置
				make memuconfig
				make gconfig
				make kconfig
					make oldconfig
					make config
				保存为.config
			2 安装
				make 
				make modules_install 
				make install 
				
				模块安装位置在： /lib/modules/Kernek——version/
			
		如何实现部分编译：
			1 只编译某子目录下的相关代码
				make dir/
					make arch/
					make drivers/net/
					
			2 只编译部分模块
				make M=drivers/net/  ：只编译与网络相关的模块
				
			3 只编译某一模块
				make drivers/net/pcnet32.ko
			4 将编译过完成的结果放置于别的目录中
				make O=/tmp/kernel
			5 交叉编译
				make ARCH=
			
53  变量赋值
	
			1	表达式的值
					${parameter:-word} : 如果parameter为空或未定义，则表达式的值展开为word,否则，展开为parameter的值 
										A=${A:-30} :如果A不为空，则A取原来的值，如果A为空，则A取30
					${parameter:+word} : 如果parameter为空或未定义，不做任何操作,否则，表达式的值展开为word的值
										${A:+30} :如果A不为空，则A取30， 如果A为空，则A取空值
					${parameter:=word} : 如果parameter为空或未定义，则将表达式展开为word, 并将展开后的值赋给parameter 
										${A:=word}: 如果A为空，则表达式展开为30，并将30赋给A, 如果A不为空，则将A的值展开为表达式的值
										
					截取子串，做字符串切片					
					${parameter:offset} 
					${parameter:offset:length} : 取子串 从offset处的后一个字符开始、取length长的子串 
						A='Hello world'
						echo ${A:2}
						echo ${A:2:3}
							root@slave1:~# A='hello world'
							root@slave1:~# echo ${A:2}
							llo world
							root@slave1:~# echo ${A:2:3}
							llo
			2   变量中字符的长度：${#VarName}
								root@slave1:~# echo $A
								hello world
								root@slave1:~# echo ${#A}
								11

			3   脚本配置文件
				服务脚本支持配置文件： /etc/sysconfig/服务脚本同名的配置文本
				
				如何让脚本使用配置文件
					在脚本中添加一行
						. /path/to/config ： 表示使配置文件生效
					或  source /path/to/config 	
		    4   函数中的局部变量和全局变量同名怎么办？
						  1 #!/bin/bash
						  2 # 
						  3 a=1
						  4 test() {
						  5 local a=$[3+4]   # 加上local 就只在函数内部有效， 输出1,2,3...10  不加则输出7,8,9,10 
						  6 }
						  7 test
						  8 
						  9 for I in `seq $a 10` ;do
						 10     echo $I
						 11 done
				局部变量定义  local Var_Name = ...				
				不加local且与全局变量重名，则函数内改变的值会影响全局变量，也就是说，函数就会操作全局变量	
				
54  mktemp  创建临时文件或目录
		
		mktemp /tmp/file.XX  : 在file后面添加.XX可以避免文件重名
		此命令直接返回文件的路径
		FILE=`mktemp /tmp/file.XX`
		echo $FILE
				
			-d ： 创建临时目录
		mktemp -d /tmp/file.XXXX 
		
55  在脚本中实现信号捕捉 
		kill -Single PID 
				1 UP
				2 INT
				9 KILL
			    15 TERM 
		
		在脚本中实现信号捕捉 但捕捉不了9和15
		
	trap :
		trap 'command' 信号列表 					
		
				  1 #!/bin/bash
				  2 
				  3 # 
				  4 trap 'echo "quit" ; exit 1 ' INT    # 一行执行多个语句，语句间用分号分隔即可
				  5 NET=192.168.1.
				  6 for I in {200..254} ; do
				  7     if ping -c 1 -W 1 $NET$I &> /dev/null; then
				  8         echo "$NET$I is up "
				  9     else
				 10         echo "$NET$I is down"
				 11     fi
				 12 done
		改进
				  1 #!/bin/bash
				  2 #在exit之前，清除临时文件、等等，必要的操作可以放在cleanup函数中
				  3 #
				  4 cleanup() {
				  5  echo 'quit...'
				  6  exit 1
				  7 
				  8 }
				  9 trap 'cleanup' INT
				 10 NET=192.168.1.
				 11 for I in {200..254} ; do
				 12     if ping -c 1 -W 1 $NET$I &> /dev/null; then
				 13         echo "$NET$I is up "
				 14     else
				 15         echo "$NET$I is down"
				 16     fi
				 17 done
		
		再改进
				  1 #!/bin/bash
				  2 #在exit之前，清除临时文件、等等，必要的操作可以放在cleanup函数中
				  3 #清除临时文件 
				  4 FILE=`mktemp /tmp/file.XXXX`
				  5 cleanup() {
				  6  echo 'quit...'
				  7  rm -f $FILE
				  8  exit 1
				  9 
				 10 }
				 11 trap 'cleanup' INT
				 12 NET=192.168.1.
				 13 for I in {200..254} ; do
				 14     if ping -c 1 -W 1 $NET$I &> /dev/null; then
				 15         echo "$NET$I is up " 
				 16     else
				 17         echo "$NET$I is down" | tee >> $FILE
				 18     fi
				 19 done
		
56  			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
		
		
		
